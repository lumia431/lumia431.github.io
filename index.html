<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Lummy的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lummy的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Lummy的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lummy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Lummy的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lummy的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-第六章：编译期反射private成员" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/09/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84private%E6%88%90%E5%91%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-09T09:02:28.358Z" itemprop="datePublished">2025-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是对你提供的内容进行的<strong>格式优化版本</strong>，不改动内容，只调整排版、标题层级、代码块标识、空行逻辑、强调方式等，以提升可读性和专业性：</p>
<hr>
<h1 id="第六章：编译期反射-private-成员"><a href="#第六章：编译期反射-private-成员" class="headerlink" title="第六章：编译期反射 private 成员"></a>第六章：编译期反射 private 成员</h1><blockquote>
<p>上一章我们已经介绍了对于聚合类型的编译期反射，本章我们介绍对于非聚合类型如何反射。</p>
</blockquote>
<p>首先看一下知乎的 <strong>YKIKO</strong> 在有状态黑魔法中提到的例子：<br>👉 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/646752343">https://zhuanlan.zhihu.com/p/646752343</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money = <span class="number">999&#x27;999&#x27;999&#x27;999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Thief</span>&lt;&amp;Bank::money&gt;;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&amp;Bank::money</code> 是一个<strong>成员变量指针</strong>，不同于普通的指针，它并不依赖于某个对象，而表示该成员在类中的偏移量，是一个<strong>编译期常量</strong>。</p>
<p>而这里的 <code>Thief</code> 是一个**非类型参数（NTTP）**的类模板，我们传了一个成员变量指针作为参数。</p>
<hr>
<h2 id="🌟-非类型模板参数（Non-Type-Template-Parameter-NTTP）"><a href="#🌟-非类型模板参数（Non-Type-Template-Parameter-NTTP）" class="headerlink" title="🌟 非类型模板参数（Non-Type Template Parameter, NTTP）"></a>🌟 非类型模板参数（Non-Type Template Parameter, NTTP）</h2><p>C++ 模板的非类型参数允许你在编译时提供具体的值，比如常量、指针、枚举、成员指针等，以此增强模板的灵活性。</p>
<h3 id="🧾-基本语法"><a href="#🧾-基本语法" class="headerlink" title="🧾 基本语法"></a>🧾 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T arr[N]; <span class="comment">// 数组大小为 N</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里，<code>N</code> 是非类型模板参数，用于指定数组大小。</p>
<hr>
<h3 id="🧪-使用示例"><a href="#🧪-使用示例" class="headerlink" title="🧪 使用示例"></a>🧪 使用示例</h3><h4 id="1-常量整数"><a href="#1-常量整数" class="headerlink" title="1. 常量整数"></a>1. 常量整数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;N = &quot;</span> &lt;&lt; N &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printN</span>&lt;<span class="number">10</span>&gt;(); <span class="comment">// 输出 N = 10</span></span><br><span class="line">    <span class="built_in">printN</span>&lt;<span class="number">20</span>&gt;(); <span class="comment">// 输出 N = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-指针或引用"><a href="#2-指针或引用" class="headerlink" title="2. 指针或引用"></a>2. 指针或引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T* ptr&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointerWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer address: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    PointerWrapper&lt;<span class="type">int</span>, &amp;x&gt; pw;</span><br><span class="line">    pw.<span class="built_in">printPointer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-枚举类型"><a href="#3-枚举类型" class="headerlink" title="3. 枚举类型"></a>3. 枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Color c&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(c == Color::Red)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Red\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (c == Color::Green) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Green\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Blue\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printColor</span>&lt;Color::Red&gt;();</span><br><span class="line">    <span class="built_in">printColor</span>&lt;Color::Green&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="👀-显示实例化与私有访问权限"><a href="#👀-显示实例化与私有访问权限" class="headerlink" title="👀 显示实例化与私有访问权限"></a>👀 显示实例化与私有访问权限</h2><p>这里还用到了模板<strong>显示实例化时会忽略类作用域访问权限</strong>的特性。</p>
<h3 id="🔍-什么是显示实例化？"><a href="#🔍-什么是显示实例化？" class="headerlink" title="🔍 什么是显示实例化？"></a>🔍 什么是显示实例化？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;        <span class="comment">// 显式实例化类模板</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myFunc</span>&lt;<span class="type">double</span>&gt;();     <span class="comment">// 显式实例化函数模板</span></span><br></pre></td></tr></table></figure>

<p>这强制编译器在该位置生成实例代码，而不是等到首次使用。</p>
<h3 id="✅-优点"><a href="#✅-优点" class="headerlink" title="✅ 优点"></a>✅ 优点</h3><ul>
<li>减少编译时间</li>
<li>减少重复实例化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;; <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>

<p>其他文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;; <span class="comment">// 声明：避免重复生成</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚠️-无法访问-private-成员的问题"><a href="#⚠️-无法访问-private-成员的问题" class="headerlink" title="⚠️ 无法访问 private 成员的问题"></a>⚠️ 无法访问 private 成员的问题</h2><p>即便你显示实例化了 <code>Thief&lt;&amp;Bank::money&gt;</code>，你仍然无法使用它的成员函数。</p>
<p>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp = &amp;Bank::money&gt;</span><br><span class="line"><span class="keyword">struct</span> Thief &#123;</span><br><span class="line">    <span class="type">double</span>&amp; <span class="built_in">steal</span>(Bank&amp; bank) &#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span>&amp; <span class="title">steal2</span><span class="params">(Bank&amp; bank)</span> </span>&#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>想使用 <code>Thief&lt;&amp;Bank::money&gt;</code>，编译器仍然报错——无法访问 <code>Bank::money</code>，因为它是 private。</p>
<hr>
<h2 id="🪄-解决方案：友元函数-显示实例化"><a href="#🪄-解决方案：友元函数-显示实例化" class="headerlink" title="🪄 解决方案：友元函数 + 显示实例化"></a>🪄 解决方案：友元函数 + 显示实例化</h2><p>利用<strong>友元函数</strong>的特性，可以在类模板内部定义，在外部声明，从而绕开访问权限。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money = <span class="number">999&#x27;999&#x27;999&#x27;999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span> </span>&#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Thief</span>&lt;&amp;Bank::money&gt;; <span class="comment">// #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bank bank;</span><br><span class="line">    <span class="built_in">steal</span>(bank) = <span class="number">100</span>; <span class="comment">// #3</span></span><br><span class="line">    bank.<span class="built_in">check</span>(); <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-泛化实现：反射-private-成员"><a href="#🧩-泛化实现：反射-private-成员" class="headerlink" title="🧩 泛化实现：反射 private 成员"></a>🧩 泛化实现：反射 private 成员</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span>... field&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">private_visitor</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_private_ptrs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(field...);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFL_PRIVATE(STRUCT, ...) \</span></span><br><span class="line"><span class="meta">  inline constexpr auto get_private_ptrs(); \</span></span><br><span class="line"><span class="meta">  template struct private_visitor<span class="string">&lt;STRUCT, ##__VA_ARGS__&gt;</span>;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">    Field&lt;std::string&gt; m_name;</span><br><span class="line">    Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REFL_PRIVATE</span>(PersonPrivate, &amp;PersonPrivate::m_name, &amp;PersonPrivate::m_age, &amp;PersonPrivate::m_male)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧭-为了避免-ODR-冲突-——-添加类型参数"><a href="#🧭-为了避免-ODR-冲突-——-添加类型参数" class="headerlink" title="🧭 为了避免 ODR 冲突 —— 添加类型参数"></a>🧭 为了避免 ODR 冲突 —— 添加类型参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span>... field&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">private_visitor</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_private_ptrs</span><span class="params">(<span class="type">const</span> my_wrapper&lt;T&gt;&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(field...);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFL_PRIVATE(STRUCT, ...) \</span></span><br><span class="line"><span class="meta">  inline constexpr auto get_private_ptrs(const my_wrapper<span class="string">&lt;STRUCT&gt;</span> &amp;t); \</span></span><br><span class="line"><span class="meta">  template struct private_visitor<span class="string">&lt;STRUCT, ##__VA_ARGS__&gt;</span>;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧠-SFINAE-萃取成员类型"><a href="#🧠-SFINAE-萃取成员类型" class="headerlink" title="🧠 SFINAE 萃取成员类型"></a>🧠 SFINAE 萃取成员类型</h2><p>我们可以从成员指针中推导其类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C, T C::*MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>&lt;MemberPtr&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">    <span class="keyword">using</span> class_type = C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">using</span> member_value_v = <span class="keyword">typename</span> MemberPointerTraits&lt;MemberPtr&gt;::type;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🎯-获取成员变量名"><a href="#🎯-获取成员变量名" class="headerlink" title="🎯 获取成员变量名"></a>🎯 获取成员变量名</h2><p>我们可以利用 <code>NTTP + __PRETTY_FUNCTION__</code> 获取成员变量的名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> ptr&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> std::string_view <span class="title">get_member_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> func_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们实现了：</p>
<ul>
<li>✅ 聚合类型的反射</li>
<li>✅ 非聚合类型的反射</li>
<li>✅ 编译期萃取字段类型</li>
<li>✅ 编译期获取字段名称</li>
</ul>
<p>真正意义上的<strong>非侵入式编译期反射机制</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Field</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_wrapper</span> &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">static</span> T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span>... field&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">private_visitor</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_private_ptrs</span><span class="params">(<span class="type">const</span> my_wrapper&lt;T&gt;&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(field...);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFL_PRIVATE(STRUCT, ...)                                         \</span></span><br><span class="line"><span class="meta">  inline constexpr auto get_private_ptrs(const my_wrapper<span class="string">&lt;STRUCT&gt;</span> &amp;t);      \</span></span><br><span class="line"><span class="meta">  template struct private_visitor<span class="string">&lt;STRUCT, ##__VA_ARGS__&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REFL_PRIVATE</span>(PersonPrivate, &amp;PersonPrivate::m_name, &amp;PersonPrivate::m_age, &amp;PersonPrivate::m_male)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyType</span> &#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">size_t</span> <span class="title">countMember</span><span class="params">(<span class="keyword">auto</span>&amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!<span class="keyword">requires</span> &#123; T&#123; Args... &#125;; &#125;)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">sizeof</span>...(Args) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">countMember</span>&lt;T&gt;(Args..., AnyType&#123;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> member_count_v = <span class="built_in">countMember</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> T&amp; <span class="title">get_global_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_wrapper&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span>&lt;Field&lt;T&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">check_field</span><span class="params">(<span class="type">const</span> Tuple&amp; tuple)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">apply</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp;... args) &#123;</span><br><span class="line">		((found = found || Is_Field&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(args)&gt;&gt;()), ...);</span><br><span class="line">		&#125;, tuple);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> ptr&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">	<span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">	<span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	std::cout &lt;&lt; func_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectHelper</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RFL_STRUCT(n, ...)                                                      \</span></span><br><span class="line"><span class="meta">template <span class="string">&lt;class T&gt;</span>                                                              \</span></span><br><span class="line"><span class="meta">struct ReflectHelper<span class="string">&lt;T, n&gt;</span> &#123;												    \</span></span><br><span class="line"><span class="meta">	static constexpr auto reflectFieldImpl() &#123;									\</span></span><br><span class="line"><span class="meta">		auto&amp; [__VA_ARGS__] = get_global_object<span class="string">&lt;T&gt;</span>();                           \</span></span><br><span class="line"><span class="meta">		auto ref_tup = std::tie(__VA_ARGS__);                                   \</span></span><br><span class="line"><span class="meta">		return check_field(ref_tup);                                            \</span></span><br><span class="line"><span class="meta">	&#125;																		    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">1</span>, f0);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">2</span>, f0, f1);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">3</span>, f0, f1, f2);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">4</span>, f0, f1, f2, f3);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">5</span>, f0, f1, f2, f3, f4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> ptr&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> std::string_view <span class="title">get_member_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> func_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C, T C::*MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>&lt;MemberPtr&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">    <span class="keyword">using</span> class_type = C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">using</span> member_value_v = <span class="keyword">typename</span> MemberPointerTraits&lt;MemberPtr&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> IsAggregate = std::is_aggregate_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectField</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">reflect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = <span class="built_in">get_private_ptrs</span>(my_wrapper&lt;T&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">size_t</span> N = std::tuple_size_v&lt;<span class="keyword">decltype</span>(tp)&gt;;</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        [&amp;]&lt;<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">            ((found = found || Is_Field&lt;member_value_v&lt;std::<span class="built_in">get</span>&lt;Is&gt;(tp)&gt;&gt;()), ...);</span><br><span class="line">        &#125;(std::make_index_sequence&lt;N&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;IsAggregate T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectField</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reflect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ReflectHelper&lt;T, member_count_v&lt;T&gt;&gt;::<span class="built_in">reflectFieldImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> reflectField_v = ReflectField&lt;T&gt;::<span class="built_in">reflect</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!reflectField_v&lt;Dog&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reflectField_v&lt;Person&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reflectField_v&lt;PersonPrivate&gt;);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = <span class="built_in">get_private_ptrs</span>(my_wrapper&lt;PersonPrivate&gt;&#123;&#125;);</span><br><span class="line">    [&amp;]&lt;<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">        (std::cout &lt;&lt; ... &lt;&lt; get_member_name&lt;std::<span class="built_in">get</span>&lt;Is&gt;(tp)&gt;());</span><br><span class="line">    &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;<span class="keyword">decltype</span>(tp)&gt;&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/09/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84private%E6%88%90%E5%91%98/" data-id="cmagyo5st0001voky8klb07k0" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-第五章：编译期反射初探！！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2025-05-09T05:21:27.878Z" itemprop="datePublished">2025-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/">第五章：编译期反射初探！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="第五章：编译期反射初探！"><a href="#第五章：编译期反射初探！" class="headerlink" title="第五章：编译期反射初探！"></a>第五章：编译期反射初探！</h1><p>在前面，我们提高了除了标签分发，还可以通过编译期反射来判断类的成员有没有某个类型。</p>
<blockquote>
<p><strong>反射</strong>是程序在<strong>运行时或编译期</strong>能够**“自我检查、自我操作”的能力**。</p>
</blockquote>
<blockquote>
<p>程序可以“知道自己有哪些类、成员变量、类型信息”，甚至<strong>动态地访问和修改它们</strong>。</p>
</blockquote>
<blockquote>
<p>编译期反射：在<strong>编译期间</strong>就可以分析、枚举、获取类型的成员信息。</p>
</blockquote>
<blockquote>
<p>C++26 正式加入反射：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;meta&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; <span class="type">double</span> y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">void</span> <span class="title">analyze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::meta;</span><br><span class="line">    <span class="keyword">auto</span> info = <span class="built_in">reflexpr</span>(A);  <span class="comment">// 反射出类型信息</span></span><br><span class="line">    <span class="keyword">auto</span> members = <span class="built_in">members_of</span>(info); <span class="comment">// 获取所有成员</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : members) &#123;</span><br><span class="line">        std::<span class="built_in">println</span>(<span class="string">&quot;Member: &#123;&#125;&quot;</span>, <span class="built_in">name_of</span>(m)); <span class="comment">// 打印每个成员的名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前常见的编译期反射库基本都是侵入式的，就是在类内定义一个宏来注册一些方法帮助反射，本章带领大家实现一个简单的非侵入式的编译期反射。<br>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REFL_PRIVATE</span>(PersonPrivate, &amp;PersonPrivate::m_name, &amp;PersonPrivate::m_age, &amp;PersonPrivate::m_male)</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(BasicTest, FieldTest) &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!reaction::reflectField_v&lt;Dog&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reaction::reflectField_v&lt;Person&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reaction::reflectField_v&lt;PersonPrivate&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要分别对aggregate类型和非聚合类型反射：</p>
<p>在 C++ 中，<code>POD</code>、<code>Trivial</code> 和 <code>Aggregate</code> 类型虽然有重叠，但它们有不同的定义侧重点，理解这些概念对于深入掌握类型系统、内存布局和构造行为非常重要。下面我通过<strong>定义 + 举例 + 差异说明</strong>来讲解这三者的区别。</p>
<h3 id="1-POD（Plain-Old-Data）类型"><a href="#1-POD（Plain-Old-Data）类型" class="headerlink" title="1. POD（Plain Old Data）类型"></a>1. POD（Plain Old Data）类型</h3><p><strong>定义</strong>：满足以下两个条件的类型：</p>
<ul>
<li>是 Trivial 类型（平凡构造&#x2F;析构&#x2F;复制&#x2F;移动）</li>
<li>是 Standard Layout 类型（布局规则简单，兼容 C）</li>
</ul>
<p>📌 <strong>用途</strong>：可与 C 语言数据结构兼容（可 <code>memcpy</code> 拷贝等）</p>
<h3 id="2-Trivial-类型"><a href="#2-Trivial-类型" class="headerlink" title="2. Trivial 类型"></a>2. Trivial 类型</h3><p><strong>定义</strong>：具有以下特征的类型：</p>
<ul>
<li>构造函数、析构函数是编译器默认生成的（且没被用户定义）</li>
<li>拷贝&#x2F;移动构造和赋值操作符也必须是默认的</li>
<li>没有虚函数、没有虚基类</li>
</ul>
<p>📌 <strong>用途</strong>：构造&#x2F;析构开销为零，可 <code>memset</code> 初始化</p>
<h3 id="3-Aggregate-类型"><a href="#3-Aggregate-类型" class="headerlink" title="3. Aggregate 类型"></a>3. Aggregate 类型</h3><p><strong>定义</strong>：聚合类型（C++17 后有所放宽），满足以下条件：</p>
<ul>
<li>没有用户提供的构造函数（注意默认构造函数是 OK 的）</li>
<li>没有 private&#x2F;protected 的非静态成员</li>
<li>没有基类</li>
<li>没有虚函数表（vtable）</li>
</ul>
<p>📌 <strong>用途</strong>：可以使用大括号 <code>&#123;&#125;</code> 初始化所有成员（aggregate initialization）</p>
<p><code>Standard-layout</code>（标准布局类型）是 C++ 中一个与内存布局紧密相关的类型特性，用于确保类型的成员排列方式在不同编译器中行为一致，便于进行底层操作，如 <code>memcpy</code>、C&#x2F;C++ 混合编程等。</p>
<h2 id="Standard-layout-类型定义"><a href="#Standard-layout-类型定义" class="headerlink" title="Standard-layout 类型定义"></a>Standard-layout 类型定义</h2><p>一个类型是 <strong>standard-layout</strong>，必须满足以下条件（C++11 起）：</p>
<ol>
<li>所有非静态成员的访问权限必须一致（都为 <code>public</code>、<code>protected</code> 或 <code>private</code>）；</li>
<li>没有虚函数；</li>
<li>没有虚基类；</li>
<li>所有非静态成员都必须是标准布局类型；</li>
<li>所有基类（如果有）都是标准布局类型；</li>
<li>至多有一个基类；</li>
<li>派生类中第一个非静态成员与其第一个非静态基类不能是同一类型（避免二义性）；</li>
<li>所有非静态数据成员必须在其自身类或基类中声明（不能跨类出现歧义）；</li>
<li>不使用空基类优化（Empty Base Optimization, EBO）；</li>
</ol>
<p>📌 <strong>重点目的</strong>：使类型的内存布局“可预测、紧凑、无重排”。</p>
<hr>
<p>在完成这个浩大的工程之前，让我们先从C++17引入的结构化绑定开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = Person&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们把这三个元素打包成一个tuple遍历不就行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = Person&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> ref_tup = std::<span class="built_in">tie</span>(m1, m2, m3);</span><br></pre></td></tr></table></figure>

<p>问题是我们是编译期反射，显然<code>Person&#123;&#125;</code>是一个运行期的值，所以ref_tup也是一个运行期的tuple，那么我们如何获取一个编译期的<code>Person</code>呢？</p>
<p>全局变量由于它的地址是编译时已知的，所以它可以被当成一个编译期常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person g_p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp;&amp; ref = g_p;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp;&amp; ref2 = p; <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我们不可能为每个要反射的类型写一个全局变量，我们可以用一个全局变量模板抽象一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> g_value = T&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = g_value&lt;Person&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ref_tup = std::<span class="built_in">tie</span>(m1, m2, m3); <span class="comment">//（这里msvc居然编译不通过，坑啊）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里还有个更好的写法，就是inline static静态成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_wrapper</span> &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">static</span> T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> T&amp; <span class="title">get_global_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_wrapper&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = <span class="built_in">get_global_object</span>&lt;Person&gt;();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ref_tup = std::<span class="built_in">tie</span>(m1, m2, m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>inline static</code> 成员变量在 C++17 之后是隐式初始化的（默认初始化或零初始化），并且它的生命周期是整个程序的运行时间（静态存储期）。</li>
<li>由于它是一个全局唯一的实例，它的地址在编译时是已知的（即使它的值可能在运行时初始化）</li>
</ul>
<p>这里的inline是必须的，否则value就只有声明，没有定义，违反ODR原则。<br>ODR（One Definition Rule）是 C++ 中的一条规则，它要求一个类型、函数或者变量在整个程序中只能有一个定义。</p>
<p>至此，我们已经成功一大半了，剩下的工作就是用元编程技术对这个tuple遍历并判断是否存在Field类型了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span>&lt;Field&lt;T&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">check_field</span><span class="params">(<span class="type">const</span> Tuple&amp; tuple)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">apply</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp;... args) &#123;</span><br><span class="line">		((found = found || Is_Field&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(args)&gt;&gt;()), ...);</span><br><span class="line">		&#125;, tuple);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题来了，我们在结构化绑定的时候是手动指定了三个成员，那么如何适配N个成员？</p>
<p>首先我们要在编译期计算类型有多少个成员？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyType</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">size_t</span> <span class="title">countMember</span><span class="params">(<span class="keyword">auto</span>&amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!<span class="keyword">requires</span> &#123; T&#123;Args...&#125;; &#125;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>...(Args) - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countMember</span>&lt;T&gt;(Args..., AnyType&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> member_count_v = <span class="built_in">countMember</span>&lt;T&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AnyType的转换函数只需声明就行，requires检测也就是SFINAE技术是在模板参数替换阶段（也就是编译器尝试具体化模板时）进行语法层面的“合法性检查”，而不是运行或完整编译代码。</p>
<p>这里使用了模板递归，AnyType可以转换为任意类型，一直用requires检测T构造函数的合法性：</p>
<p>T{}, T{any}, T{any1, any2}, T{any1, any2, any3}，直到失败了即说明参数给多了，此时sizeof…(Args) - 1即为成员数量。</p>
<p>最后在用一个变量模板包装一下，这也符合标准库的习惯。</p>
<p>现在得到了成员数量，如何根据成员数量指定结构体绑定解包的数量，这里要借助宏来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectHelper</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RFL_STRUCT(n, ...)                                                      \</span></span><br><span class="line"><span class="meta">template <span class="string">&lt;class T&gt;</span>                                                              \</span></span><br><span class="line"><span class="meta">struct ReflectHelper<span class="string">&lt;T, n&gt;</span> &#123;												    \</span></span><br><span class="line"><span class="meta">	static constexpr auto reflectFieldImpl() &#123;									\</span></span><br><span class="line"><span class="meta">		auto&amp; [__VA_ARGS__] = get_fake_object<span class="string">&lt;T&gt;</span>();                             \</span></span><br><span class="line"><span class="meta">		auto ref_tup = std::tie(__VA_ARGS__);                                   \</span></span><br><span class="line"><span class="meta">		return check_field(ref_tup);                                            \</span></span><br><span class="line"><span class="meta">	&#125;																		    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">1</span>, f0);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">2</span>, f0, f1);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">3</span>, f0, f1, f2);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">4</span>, f0, f1, f2, f3);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">5</span>, f0, f1, f2, f3, f4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reflectField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ReflectHelper&lt;T, member_count_v&lt;T&gt;&gt;::<span class="built_in">reflectFieldImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们可以通过reflectField函数模板来判断Person是否包含Field类型了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> reflectField_v = <span class="built_in">reflectField</span>&lt;T&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Field</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyType</span> &#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">size_t</span> <span class="title">countMember</span><span class="params">(<span class="keyword">auto</span>&amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!<span class="keyword">requires</span> &#123; T&#123; Args... &#125;; &#125;)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">sizeof</span>...(Args) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">countMember</span>&lt;T&gt;(Args..., AnyType&#123;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> member_count_v = <span class="built_in">countMember</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_wrapper</span> &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">static</span> T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> T&amp; <span class="title">get_global_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_wrapper&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span>&lt;Field&lt;T&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">check_field</span><span class="params">(<span class="type">const</span> Tuple&amp; tuple)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">apply</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp;... args) &#123;</span><br><span class="line">		((found = found || Is_Field&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(args)&gt;&gt;()), ...);</span><br><span class="line">		&#125;, tuple);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> ptr&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">	<span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">	<span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	std::cout &lt;&lt; func_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectHelper</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RFL_STRUCT(n, ...)                                                      \</span></span><br><span class="line"><span class="meta">template <span class="string">&lt;class T&gt;</span>                                                              \</span></span><br><span class="line"><span class="meta">struct ReflectHelper<span class="string">&lt;T, n&gt;</span> &#123;												    \</span></span><br><span class="line"><span class="meta">	static constexpr auto reflectFieldImpl() &#123;									\</span></span><br><span class="line"><span class="meta">		auto&amp; [__VA_ARGS__] = get_global_object<span class="string">&lt;T&gt;</span>();                           \</span></span><br><span class="line"><span class="meta">		auto ref_tup = std::tie(__VA_ARGS__);                                   \</span></span><br><span class="line"><span class="meta">		return check_field(ref_tup);                                            \</span></span><br><span class="line"><span class="meta">	&#125;																		    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">1</span>, f0);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">2</span>, f0, f1);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">3</span>, f0, f1, f2);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">4</span>, f0, f1, f2, f3);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">5</span>, f0, f1, f2, f3, f4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reflectField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ReflectHelper&lt;T, member_count_v&lt;T&gt;&gt;::<span class="built_in">reflectFieldImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> reflectField_v = <span class="built_in">reflectField</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!reflectField_v&lt;Dog&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reflectField_v&lt;Person&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/" data-id="cmagyo5sa0000vokyans0h8ue" data-title="第五章：编译期反射初探！" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" rel="tag">\[Reactive-programming, C++, Modern-Cpp, TMP]</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第三章：实现数据源的生命周期管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-05-07T01:54:09.729Z" itemprop="datePublished">2025-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/">第三章：实现数据源的生命周期管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第三章：实现数据源的生命周期管理"><a href="#第三章：实现数据源的生命周期管理" class="headerlink" title="第三章：实现数据源的生命周期管理"></a>第三章：实现数据源的生命周期管理</h1><h2 id="设计目标回顾"><a href="#设计目标回顾" class="headerlink" title="设计目标回顾"></a>设计目标回顾</h2><p>在前两章中，我们已经建立了Reaction框架的基础结构，本章将重点解决以下问题：</p>
<ol>
<li>实现数据源的拷贝和移动语义</li>
<li>使用智能指针和引用计数管理内存</li>
<li>确保用户只持有弱引用，强引用由ObserverGraph统一管理</li>
</ol>
<h2 id="核心设计：桥接模式与智能指针管理"><a href="#核心设计：桥接模式与智能指针管理" class="headerlink" title="核心设计：桥接模式与智能指针管理"></a>核心设计：桥接模式与智能指针管理</h2><h3 id="1-桥接模式的应用"><a href="#1-桥接模式的应用" class="headerlink" title="1. 桥接模式的应用"></a>1. 桥接模式的应用</h3><p>桥接模式（Bridge Pattern）是面向对象设计中的经典模式，其核心思想是将抽象（Abstraction）与实现（Implementation）分离，使二者可以独立变化。这种分离通过组合（Composition）而非继承（Inheritance）实现，是”组合优于继承”原则的典型体现。</p>
<p>在Reaction框架中，我们通过以下结构实现桥接模式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReactType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">React</span> &#123; <span class="comment">/* 抽象接口层 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TriggerPolicy, <span class="keyword">typename</span> InvalidStrategy, <span class="keyword">typename</span> Type, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReactImpl</span> : <span class="keyword">public</span> Expression&lt;TriggerPolicy, Type, Args...&gt;,</span><br><span class="line">                  <span class="keyword">public</span> InvalidStrategy &#123; <span class="comment">/* 实现层 */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>桥接模式的优势</strong>：</p>
<ul>
<li>接口(<code>React</code>)与实现(<code>ReactImpl</code>)可以独立变化</li>
<li>隐藏了复杂的模板参数和实现细节</li>
<li>用户只需与简洁的<code>React</code>接口交互</li>
</ul>
<h3 id="2-智能指针与引用计数"><a href="#2-智能指针与引用计数" class="headerlink" title="2. 智能指针与引用计数"></a>2. 智能指针与引用计数</h3><p>我们采用三级引用管理策略：</p>
<ol>
<li><strong>强引用</strong>：由<code>ObserverGraph</code>统一管理，确保活跃数据源不会被意外释放</li>
<li><strong>弱引用</strong>：用户持有的<code>React</code>对象内部使用<code>std::weak_ptr</code></li>
<li><strong>弱引用计数</strong>：<code>ReactImpl</code>内部维护<code>m_weakRefCount</code>，用于跟踪弱引用数量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">React</span> &#123;</span><br><span class="line">    std::weak_ptr&lt;ReactType&gt; m_weakPtr; <span class="comment">// 用户只持有弱引用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReactImpl</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; m_weakRefCount&#123;<span class="number">0</span>&#125;; <span class="comment">// 弱引用计数器</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现关键点"><a href="#实现关键点" class="headerlink" title="实现关键点"></a>实现关键点</h2><h3 id="1-拷贝语义实现"><a href="#1-拷贝语义实现" class="headerlink" title="1. 拷贝语义实现"></a>1. 拷贝语义实现</h3><p>拷贝构造和拷贝赋值需要正确处理弱引用计数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React的拷贝构造函数</span></span><br><span class="line"><span class="built_in">React</span>(<span class="type">const</span> React &amp;other) : <span class="built_in">m_weakPtr</span>(other.m_weakPtr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">        p-&gt;<span class="built_in">addWeakRef</span>(); <span class="comment">// 增加弱引用计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React的拷贝赋值运算符</span></span><br><span class="line">React &amp;<span class="keyword">operator</span>=(<span class="type">const</span> React &amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">            p-&gt;<span class="built_in">releaseWeakRef</span>(); <span class="comment">// 释放旧引用</span></span><br><span class="line">        m_weakPtr = other.m_weakPtr;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">            p-&gt;<span class="built_in">addWeakRef</span>(); <span class="comment">// 增加新引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-移动语义实现"><a href="#2-移动语义实现" class="headerlink" title="2. 移动语义实现"></a>2. 移动语义实现</h3><p>移动操作需要转移所有权并重置原对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React的移动构造函数</span></span><br><span class="line"><span class="built_in">React</span>(React &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">m_weakPtr</span>(std::<span class="built_in">move</span>(other.m_weakPtr)) &#123;</span><br><span class="line">    other.m_weakPtr.<span class="built_in">reset</span>(); <span class="comment">// 原对象放弃所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React的移动赋值运算符</span></span><br><span class="line">React &amp;<span class="keyword">operator</span>=(React &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">            p-&gt;<span class="built_in">releaseWeakRef</span>();</span><br><span class="line">        m_weakPtr = std::<span class="built_in">move</span>(other.m_weakPtr);</span><br><span class="line">        other.m_weakPtr.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-弱引用计数管理"><a href="#3-弱引用计数管理" class="headerlink" title="3. 弱引用计数管理"></a>3. 弱引用计数管理</h3><p><code>ReactImpl</code>需要提供弱引用计数的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWeakRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_weakRefCount++; <span class="comment">// 原子操作增加计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseWeakRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--m_weakRefCount == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ObserverGraph::<span class="built_in">getInstance</span>().<span class="built_in">removeNode</span>(<span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Safe-Bool-Idiom（安全布尔惯用法）的历史"><a href="#Safe-Bool-Idiom（安全布尔惯用法）的历史" class="headerlink" title="Safe Bool Idiom（安全布尔惯用法）的历史"></a><strong>Safe Bool Idiom（安全布尔惯用法）的历史</strong></h3><p>在 C++11 之前，C++ 没有直接支持安全的布尔转换机制，导致开发者需要设计各种技巧来防止隐式转换带来的问题。<strong>Safe Bool Idiom</strong> 就是在这个背景下诞生的，它的演进可以分为三个阶段：</p>
<hr>
<h2 id="1-原始-operator-bool-的问题（C-98-03）"><a href="#1-原始-operator-bool-的问题（C-98-03）" class="headerlink" title="1. 原始 operator bool 的问题（C++98&#x2F;03）"></a><strong>1. 原始 <code>operator bool</code> 的问题（C++98&#x2F;03）</strong></h2><p>在早期 C++ 中，如果一个类定义了 <code>operator bool()</code>，它会允许 <strong>隐式转换</strong>，导致许多意外的行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">isValid</span>(); &#125; <span class="comment">// 隐式转换</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FileHandle file;</span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">/* OK */</span> &#125;</span><br><span class="line"><span class="type">int</span> x = file; <span class="comment">// 糟糕！file 被隐式转换成 bool，再转成 int（可能非预期）</span></span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ul>
<li>允许 <code>FileHandle</code> 隐式转换成 <code>bool</code>，进而可能参与算术运算（如 <code>file + 5</code>）。</li>
<li>可能与其他类型发生意外的隐式转换（如 <code>if (file == nullptr)</code> 可能编译通过，但逻辑错误）。</li>
</ul>
<hr>
<h2 id="2-Safe-Bool-Idiom-的诞生（C-03-时代的解决方案）"><a href="#2-Safe-Bool-Idiom-的诞生（C-03-时代的解决方案）" class="headerlink" title="2. Safe Bool Idiom 的诞生（C++03 时代的解决方案）"></a><strong>2. Safe Bool Idiom 的诞生（C++03 时代的解决方案）</strong></h2><p>为了避免隐式转换的问题，C++ 开发者发明了 <strong>Safe Bool Idiom</strong>，主要思路是：</p>
<ul>
<li><strong>不直接返回 <code>bool</code>，而是返回一个指向成员函数的指针</strong>（通常是一个私有的、不可调用的函数）。</li>
<li>由于函数指针不能隐式转换成 <code>int</code> 或其他类型，但仍然可以在 <code>if</code>、<code>while</code> 等布尔上下文中使用。</li>
</ul>
<p><strong>实现方式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(FileHandle::*SafeBoolType)</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">SafeBoolType</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValid</span>() ? &amp;FileHandle::dummy : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125; <span class="comment">// 仅用于安全布尔转换</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FileHandle file;</span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">/* OK */</span> &#125;</span><br><span class="line"><span class="type">int</span> x = file; <span class="comment">// 编译错误！无法隐式转换</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>防止了隐式转换成 <code>int</code> 或其他类型。</li>
<li>仍然可以在布尔上下文中使用。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>代码复杂，引入了额外的成员函数和类型定义。</li>
<li>仍然有一些极端情况可能不安全（如 <code>delete file</code> 可能编译通过，但行为未定义）。</li>
</ul>
<hr>
<h2 id="3-C-11-的-explicit-operator-bool（现代解决方案）"><a href="#3-C-11-的-explicit-operator-bool（现代解决方案）" class="headerlink" title="3. C++11 的 explicit operator bool（现代解决方案）"></a><strong>3. C++11 的 <code>explicit operator bool</code>（现代解决方案）</strong></h2><p>C++11 引入了 <strong><code>explicit</code> 转换运算符</strong>，直接解决了 Safe Bool Idiom 的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">isValid</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FileHandle file;</span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">/* OK */</span> &#125;</span><br><span class="line"><span class="type">int</span> x = file; <span class="comment">// 编译错误！必须显式转换</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>语法简洁，不需要额外的辅助类型。</li>
<li>完全防止隐式转换，只允许在布尔上下文中使用。</li>
<li>被标准库广泛采用（如 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 都使用 <code>explicit operator bool</code>）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !m_weakPtr.<span class="built_in">expired</span>(); <span class="comment">// Returns true if the pointer is not null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试用例分析"><a href="#测试用例分析" class="headerlink" title="测试用例分析"></a>测试用例分析</h2><p>让我们看看测试用例如何验证这些功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestCopy) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(bb); &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + dsds; &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dds_copy = dds;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;113.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;113.140000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;223.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;223.140000&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test for moving data sources</span></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestMove) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(bb); &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + dsds; &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dds_copy = std::<span class="built_in">move</span>(dds);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;113.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dds));</span><br><span class="line">    <span class="built_in">EXPECT_THROW</span>(dds.<span class="built_in">get</span>(), std::runtime_error);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;223.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dds));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现注意事项"><a href="#实现注意事项" class="headerlink" title="实现注意事项"></a>实现注意事项</h2><ol>
<li><strong>线程安全</strong>：所有引用计数操作使用<code>std::atomic</code>保证线程安全</li>
<li><strong>异常安全</strong>：移动操作标记为<code>noexcept</code>，确保不会在转移所有权时抛出异常</li>
<li><strong>空状态检查</strong>：通过<code>operator bool()</code>允许用户检查对象有效性</li>
<li><strong>资源释放</strong>：当弱引用计数归零时，通知ObserverGraph可以释放资源</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章通过桥接模式和智能指针的巧妙结合，实现了：</p>
<ol>
<li>安全的拷贝和移动语义</li>
<li>自动化的内存管理</li>
<li>清晰的接口与实现分离</li>
<li>高效的响应式更新机制</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/" data-id="cmadrzd5800007ekybliyhoi5" data-title="第三章：实现数据源的生命周期管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第四章：让数据源作为成员变量" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/" class="article-date">
  <time class="dt-published" datetime="2025-05-03T05:56:59.613Z" itemprop="datePublished">2025-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">第四章：让数据源作为成员变量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="第四章：让数据源作为成员变量"><a href="#第四章：让数据源作为成员变量" class="headerlink" title="第四章：让数据源作为成员变量"></a>第四章：让数据源作为成员变量</h1><p>在本章中，我们将实现 <code>constVar</code>、<code>action</code> 和 <code>field</code>。</p>
<p>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestConst) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">constVar</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">5.14</span>);</span><br><span class="line">    <span class="comment">// b.value(4.14); // compile error;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestAction) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> at = reaction::<span class="built_in">action</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; aa &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; bb &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;, a, b);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="keyword">public</span> reaction::FieldBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age, <span class="type">bool</span> male)</span><br><span class="line">        : <span class="built_in">m_name</span>(<span class="built_in">field</span>(name)), <span class="built_in">m_age</span>(<span class="built_in">field</span>(age)), <span class="built_in">m_male</span>(male) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">        *m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_age.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        *m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(BasicTest, FieldTest) &#123;</span><br><span class="line">    Person person&#123;<span class="string">&quot;lummy&quot;</span>, <span class="number">18</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = reaction::<span class="built_in">var</span>(person);</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="keyword">auto</span> pp) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + pp.<span class="built_in">getName</span>(); &#125;, a, p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="string">&quot;1lummy&quot;</span>);</span><br><span class="line">    p.<span class="built_in">getRef</span>().<span class="built_in">setName</span>(<span class="string">&quot;lummy-new&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="string">&quot;1lummy-new&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="深度实现解析：基于继承的字段管理系统"><a href="#深度实现解析：基于继承的字段管理系统" class="headerlink" title="深度实现解析：基于继承的字段管理系统"></a>深度实现解析：基于继承的字段管理系统</h2><h3 id="一、核心架构设计"><a href="#一、核心架构设计" class="headerlink" title="一、核心架构设计"></a>一、核心架构设计</h3><h4 id="1-1-类关系图谱"><a href="#1-1-类关系图谱" class="headerlink" title="1.1 类关系图谱"></a>1.1 类关系图谱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class FieldBase&#123;</span><br><span class="line">        &lt;&lt;abstract&gt;&gt;</span><br><span class="line">        +uint64_t m_id</span><br><span class="line">        +field(T&amp;&amp;) React</span><br><span class="line">        +~FieldBase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Person&#123;</span><br><span class="line">        +Field&lt;std::string&gt; m_name</span><br><span class="line">        +Field&lt;int&gt; m_age</span><br><span class="line">        +bool m_male</span><br><span class="line">        +getName() string</span><br><span class="line">        +setName(string)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class FieldGraph&#123;</span><br><span class="line">        -unordered_map&lt;uint64_t, unordered_set&lt;NodePtr&gt;&gt; m_fieldMap</span><br><span class="line">        +addObj()</span><br><span class="line">        +deleteObj()</span><br><span class="line">        +setField()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ReactImpl&#123;</span><br><span class="line">        -T m_value</span><br><span class="line">        +updateObservers()</span><br><span class="line">        +addObserver()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FieldBase &lt;|-- Person</span><br><span class="line">    FieldGraph o-- ReactImpl</span><br><span class="line">    Person *-- ReactImpl</span><br></pre></td></tr></table></figure>

<h3 id="二、关键实现细节"><a href="#二、关键实现细节" class="headerlink" title="二、关键实现细节"></a>二、关键实现细节</h3><h4 id="2-1-字段注册机制（FieldBase）"><a href="#2-1-字段注册机制（FieldBase）" class="headerlink" title="2.1 字段注册机制（FieldBase）"></a>2.1 字段注册机制（FieldBase）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FieldBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">field</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建响应式节点（AlwaysTrigger策略）</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::make_shared&lt;ReactImpl&lt;AlwaysTrigger, DirectCloseStrategy, std::<span class="type">decay_t</span>&lt;T&gt;&gt;&gt;(</span><br><span class="line">            std::forward&lt;T&gt;(t)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册到全局字段图（关键点1）</span></span><br><span class="line">        FieldGraph::<span class="built_in">getInstance</span>().<span class="built_in">addObj</span>(m_id, ptr-&gt;<span class="built_in">getShared</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> React&#123;ptr&#125;;  <span class="comment">// 返回React包装</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FieldBase</span>() &#123;</span><br><span class="line">        <span class="comment">// 对象销毁时自动清理（关键点2）</span></span><br><span class="line">        FieldGraph::<span class="built_in">getInstance</span>().<span class="built_in">deleteObj</span>(m_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 唯一标识生成器（模板化实现）</span></span><br><span class="line">    UniqueID&lt;FieldBase&gt; m_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>实现要点</strong>：</p>
<ol>
<li>每个派生类实例自动获得唯一ID</li>
<li>字段构造时自动注册到所属对象</li>
<li>析构时自动解除注册</li>
</ol>
<h4 id="2-2-字段关系图（FieldGraph增强实现）"><a href="#2-2-字段关系图（FieldGraph增强实现）" class="headerlink" title="2.2 字段关系图（FieldGraph增强实现）"></a>2.2 字段关系图（FieldGraph增强实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FieldGraph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setField</span><span class="params">(<span class="type">uint64_t</span> id, NodePtr objPtr)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> it = m_fieldMap.<span class="built_in">find</span>(id); it != m_fieldMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 双向观察建立（关键点3）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; node : it-&gt;second) &#123;</span><br><span class="line">                <span class="comment">// 对象观察字段变更</span></span><br><span class="line">                node-&gt;<span class="built_in">addObserver</span>(objPtr);</span><br><span class="line">                <span class="comment">// 字段观察对象变更</span></span><br><span class="line">                objPtr-&gt;<span class="built_in">addObserver</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex m_mutex;  <span class="comment">// 线程安全保护</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">uint64_t</span>, std::unordered_set&lt;NodePtr&gt;&gt; m_fieldMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>观察关系建立流程</strong>：</p>
<ol>
<li>对象创建var时触发setField调用</li>
<li>遍历对象的所有注册字段</li>
<li>建立对象与字段的双向观察：<ul>
<li>字段变更 → 通知所属对象</li>
<li>对象变更 → 通知所有字段</li>
</ul>
</li>
</ol>
<h4 id="2-3-var模板的特化处理"><a href="#2-3-var模板的特化处理" class="headerlink" title="2.3 var模板的特化处理"></a>2.3 var模板的特化处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">var</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RawT = std::<span class="type">decay_t</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译期类型检查（关键点4）</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;FieldBase, RawT&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::make_shared&lt;ReactImpl&lt;AlwaysTrigger, DirectCloseStrategy, RawT&gt;&gt;(</span><br><span class="line">            std::forward&lt;T&gt;(t)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟建立观察关系（关键点5）</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; graph = FieldGraph::<span class="built_in">getInstance</span>();</span><br><span class="line">        graph.<span class="built_in">setField</span>(ptr-&gt;<span class="built_in">get</span>().<span class="built_in">getId</span>(), ptr-&gt;<span class="built_in">getShared</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> React&#123;ptr&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 常规处理流程</span></span><br><span class="line">        <span class="keyword">return</span> React&#123;std::make_shared&lt;ReactImpl&lt;AlwaysTrigger, DirectCloseStrategy, RawT&gt;&gt;(</span><br><span class="line">            std::forward&lt;T&gt;(t))</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计决策分析</strong>：</p>
<ul>
<li>选择<code>is_base_of_v</code>而非反射的原因：<ol>
<li><strong>编译期确定性</strong>：避免运行时类型检查开销</li>
<li><strong>更好的类型安全</strong>：强制使用FieldBase派生类</li>
<li><strong>简化实现</strong>：无需复杂反射基础设施</li>
</ol>
</li>
</ul>
<h3 id="三、生命周期管理策略"><a href="#三、生命周期管理策略" class="headerlink" title="三、生命周期管理策略"></a>三、生命周期管理策略</h3><h4 id="3-1-对象注册流程"><a href="#3-1-对象注册流程" class="headerlink" title="3.1 对象注册流程"></a>3.1 对象注册流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User</span><br><span class="line">    participant Person</span><br><span class="line">    participant FieldGraph</span><br><span class="line">    participant ReactImpl</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Person: 创建实例</span><br><span class="line">    Person-&gt;&gt;FieldBase: 构造（生成m_id）</span><br><span class="line">    loop 初始化字段</span><br><span class="line">        Person-&gt;&gt;FieldBase: field(&quot;lummy&quot;)</span><br><span class="line">        FieldBase-&gt;&gt;ReactImpl: 创建字段实例</span><br><span class="line">        FieldBase-&gt;&gt;FieldGraph: addObj(m_id, fieldPtr)</span><br><span class="line">    end</span><br><span class="line">    User-&gt;&gt;var模板: 创建数据源</span><br><span class="line">    var模板-&gt;&gt;FieldGraph: setField(m_id, objPtr)</span><br><span class="line">    FieldGraph-&gt;&gt;ReactImpl: 建立双向观察</span><br></pre></td></tr></table></figure>

<h4 id="3-2-对象销毁流程"><a href="#3-2-对象销毁流程" class="headerlink" title="3.2 对象销毁流程"></a>3.2 对象销毁流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User</span><br><span class="line">    participant Person</span><br><span class="line">    participant FieldGraph</span><br><span class="line">    participant ReactImpl</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Person: 析构实例</span><br><span class="line">    Person-&gt;&gt;FieldBase: 析构</span><br><span class="line">    FieldBase-&gt;&gt;FieldGraph: deleteObj(m_id)</span><br><span class="line">    FieldGraph-&gt;&gt;ReactImpl: 移除所有关联字段</span><br><span class="line">    ReactImpl-&gt;&gt;Observers: 自动解除观察关系</span><br></pre></td></tr></table></figure>

<p>此外，为了在 <code>var</code> 接收到自定义类型时，识别其继承 <code>FieldBase</code> 并自动调用 <code>setField</code>，建议在 <code>VarImpl</code> 构造中使用 <code>std::is_base_of_v&lt;FieldBase, T&gt;</code> 判断并分发。</p>
<h3 id="模板元编程常用技法：标签分发（Tag-Dispatching）"><a href="#模板元编程常用技法：标签分发（Tag-Dispatching）" class="headerlink" title="模板元编程常用技法：标签分发（Tag Dispatching）"></a><strong>模板元编程常用技法：标签分发（Tag Dispatching）</strong></h3><ul>
<li><strong>核心思想</strong>：通过定义空结构体（标签）表示类型特性，利用函数重载或模板特化分发到不同实现。</li>
<li><strong>典型场景</strong>：标准库算法根据迭代器类型（如 <code>std::input_iterator_tag</code>）选择最优实现。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义标签</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InputTag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RandomAccessTag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(Iter begin, Iter end, InputTag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 针对输入迭代器的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(Iter begin, Iter end, RandomAccessTag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 针对随机访问迭代器的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数：通过 traits 提取标签并分发</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(Iter begin, Iter end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Tag = <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::iterator_category;</span><br><span class="line">    <span class="built_in">algorithm</span>(begin, end, Tag&#123;&#125;); <span class="comment">// 标签分发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后，说明一下 <code>decltype(auto)</code> 的使用场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 React 对象中获取引用时：</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">getRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getReference</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>decltype(auto)</code> 是 C++14 引入的一个类型推导工具，用于根据表达式的值类型（value category）精确推导变量或返回值的类型。</p>
<h3 id="一、基本作用"><a href="#一、基本作用" class="headerlink" title="一、基本作用"></a>一、基本作用</h3><p>它的作用可以理解为：</p>
<ul>
<li><code>decltype(auto)</code> 会<strong>完全照搬</strong>表达式的类型，包括是否为引用、是否为 <code>const</code>。</li>
<li>和 <code>auto</code> 不同，<code>decltype(auto)</code> 不会移除引用或 <code>const</code> 修饰。</li>
</ul>
<h3 id="二、示例说明"><a href="#二、示例说明" class="headerlink" title="二、示例说明"></a>二、示例说明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = rx;            <span class="comment">// a 的类型是 int（引用被移除）</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) b = rx;  <span class="comment">// b 的类型是 int&amp;（引用保留）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">foo</span>();            <span class="comment">// x 是 int（右值引用被移除）</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) y = <span class="built_in">foo</span>();  <span class="comment">// y 是 int&amp;&amp;（保留右值引用）</span></span><br></pre></td></tr></table></figure>

<h3 id="三、主要应用场景"><a href="#三、主要应用场景" class="headerlink" title="三、主要应用场景"></a>三、主要应用场景</h3><ol>
<li><strong>函数返回值类型推导</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getX</span>(); <span class="comment">// 保留返回引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用 <code>auto</code>，返回值会被拷贝；用 <code>decltype(auto)</code>，可以保留引用或右值引用的属性。</p>
<ol start="2">
<li><strong>模板中精确转发和返回类型</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">forwardValue</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;T&gt;(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/" data-id="cmadrzd5s00067ekygbwbeqb6" data-title="第四章：让数据源作为成员变量" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" rel="tag">\[Reactive-programming, C++, Modern-Cpp, TMP]</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第二章：让数据流起来！依赖节点管理的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B5%B7%E6%9D%A5%EF%BC%81%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2025-04-23T08:06:30.263Z" itemprop="datePublished">2025-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B5%B7%E6%9D%A5%EF%BC%81%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/">第二章：让数据流起来！依赖节点管理的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第二章：让数据流起来！依赖节点管理的实现"><a href="#第二章：让数据流起来！依赖节点管理的实现" class="headerlink" title="第二章：让数据流起来！依赖节点管理的实现"></a>第二章：让数据流起来！依赖节点管理的实现</h1><p>在本章中，我们将实现 <code>ObserverNode</code> 和 <code>ObserverGraph</code>，从而能够正确传播数据源的调用链。</p>
<p>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestCommonUse) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(a.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(dsds); &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;14.140000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">5.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;25.140000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>众所周知，设计模式中有一个赫赫有名的<strong>观察者模式</strong>，而我们本章要做的，实际上就是一个观察者模式的实现。</p>
<p>观察者模式需要一个<strong>观察容器</strong>，但问题在于——我们的<strong>数据源是任意类型</strong>的，那么，如何把这些不同类型的数据源放进同一个容器中呢？</p>
<p>这就需要用到**类型擦除（Type Erasure）**的技术。</p>
<p>类型擦除是一种常见的编程技术，它允许你在<strong>保持类型安全</strong>的前提下，处理多种不同类型的数据，而无需在编译时知道这些类型的具体信息。</p>
<p>在 C++ 中，类型擦除是实现 <strong>“鸭子类型（Duck Typing）”</strong> 的核心手段之一。</p>
<p>所谓鸭子类型，是动态类型系统中的一种编程思想，其名字源自那句经典谚语：</p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那它就可以被认为是鸭子。”</p>
</blockquote>
<p>在鸭子类型的语义中，<strong>我们关心的是对象“能做什么”，而不是“它是什么”</strong>：</p>
<ul>
<li>不关心它是不是 <code>Duck</code> 类；</li>
<li>只关心它能不能 <code>swim()</code>、<code>walk()</code>、<code>quack()</code>。</li>
</ul>
<p>换句话说，鸭子类型强调的是<strong>行为匹配</strong>而非<strong>类型匹配</strong>，关注点在于对象的<strong>接口与能力</strong>，而非其<strong>所属类型</strong>。</p>
<p>具体地说，类型擦除是一种运行时多态技术，C++中有几种常见的类型擦除实现方式:</p>
<ul>
<li>虚函数</li>
<li><code>std::function</code></li>
<li><code>std::any</code></li>
</ul>
<p>我们今天用<strong>虚函数</strong>和<code>std::function</code>来实现类型擦除，并做一下性能对比。</p>
<h2 id="虚函数实现"><a href="#虚函数实现" class="headerlink" title="虚函数实现"></a>虚函数实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">valueChanged</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateObservers</span><span class="params">(Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">        (<span class="type">void</span>)(..., args.<span class="built_in">addObserver</span>(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;observer : m_observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">valueChanged</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;ObserverNode*&gt; m_observers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="折叠表达式解释："><a href="#折叠表达式解释：" class="headerlink" title="折叠表达式解释："></a>折叠表达式解释：</h3><p><code>(..., args.addObserver(this))</code> 这里是一个<strong>折叠表达式</strong>，属于<strong>一元左折叠</strong>，展开为一个逗号表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arg<span class="number">1.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), arg<span class="number">2.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), arg<span class="number">3.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), ...)</span><br></pre></td></tr></table></figure>

<p>逗号表达式的特点是：<strong>会依次执行前面所有项的语句，并返回最后一项的值</strong>。当然，这里也可以写成右折叠 <code>(args.addObserver(this), ...)</code>，由于逗号操作符本身是顺序执行的，其顺序不影响结果。但如果使用的是 <code>-</code> 或 <code>/</code> 等非交换的操作符，折叠方向就会影响结果。</p>
<p>为什么前面要加 <code>(void)</code>？</p>
<p>这是一个<strong>强制类型转换</strong>，将整个逗号表达式的结果转为 <code>void</code> 类型，这就形成了一个<strong>弃置表达式</strong>（discarded-value expression）。这意味着我们<strong>不关心表达式的返回值，只关心它的副作用</strong>（即每次调用 <code>addObserver(this)</code> 的效果）。</p>
<p>如果 <code>addObserver</code> 有返回值，使用 <code>(void)</code> 明确告知编译器“我不关心这个返回值”，可以避免可能出现的 <strong>“未使用返回值”警告</strong>，这是一种典型的<strong>防御性编程</strong>技巧。</p>
<p>在 C++17 之前，还不能直接使用折叠表达式，因此通常借助 <code>std::initializer_list</code> 实现类似功能的 workaround，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)std::initializer_list&lt;<span class="type">int</span>&gt;&#123;(args.<span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>)...&#125;;</span><br></pre></td></tr></table></figure>

<p>借助初始化列表的展开能力，<code>(args.addObserver(this), 0)...</code> 会生成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(arg<span class="number">1.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>), (arg<span class="number">2.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>), (arg<span class="number">3.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>我在学习现代 C++ 的时候，曾把 <strong>折叠表达式</strong> 和 <strong>包展开（parameter pack expansion）</strong> 搞混。其实两者有明显的差别，下面是几种常见的包展开形式：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>示例表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>递归函数调用</td>
<td><code>print_all(args...)</code></td>
<td>递归展开参数包</td>
</tr>
<tr>
<td>初始化容器</td>
<td><code>std::tuple&#123;args...&#125;</code></td>
<td>直接展开到初始化列表</td>
</tr>
<tr>
<td>模板参数列表</td>
<td><code>std::is_same_v&lt;Args, T&gt;...</code></td>
<td>展开到模板参数</td>
</tr>
<tr>
<td>完美转发</td>
<td><code>std::forward&lt;Args&gt;(args)...</code></td>
<td>保持值类别进行转发</td>
</tr>
</tbody></table>
<p>C++ 的包展开规则要求：<strong>展开必须发生在明确的模板或初始化上下文中</strong>，比如函数调用、初始化列表、模板参数等。<br>但对于需要运算符参与的场景，包展开本身就无法单独使用，这时就要使用折叠表达式。</p>
<h2 id="DataSource-的-value-方法实现"><a href="#DataSource-的-value-方法实现" class="headerlink" title="DataSource 的 value 方法实现"></a>DataSource 的 value 方法实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSource</span> : <span class="keyword">public</span> Expression&lt;Type, Args...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ValueType = Expression&lt;Type, Args...&gt;::ValueType;</span><br><span class="line">    <span class="keyword">using</span> ExprType = Expression&lt;Type, Args...&gt;::ExprType;</span><br><span class="line">    <span class="keyword">using</span> Expression&lt;Type, Args...&gt;::Expression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">        <span class="title">requires</span> <span class="params">(std::is_convertible_v&lt;std::<span class="type">decay_t</span>&lt;T&gt;, ValueType&gt; &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::is_same_v&lt;ExprType, VarExpr&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">value</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">updateValue</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类型萃取与别名传递"><a href="#类型萃取与别名传递" class="headerlink" title="类型萃取与别名传递"></a>类型萃取与别名传递</h3><p>至于最后提到的 <code>ValueType</code>，它是模板元编程中最经典的惯用技法之一，核心思想是一种：</p>
<blockquote>
<p><strong>类型萃取（type extraction） + 别名传递（alias propagation）</strong></p>
</blockquote>
<p>举例来说，在 STL 标准模板库中，迭代器类型通常通过如下方式萃取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::iterator_traits&lt;Iter&gt;::value_type</span><br></pre></td></tr></table></figure>

<p>这样可以<strong>统一地提取出某个迭代器的值类型</strong>。然后把这个 <code>value_type</code> 传递到容器或算法中，在执行算法时，就能根据容器中不同的 <code>value_type</code> 做出相应优化：</p>
<ul>
<li><code>std::vector</code> 是随机访问迭代器，可以直接跳跃；</li>
<li><code>std::list</code> 是单向或双向迭代器，只能一步一步前进。</li>
</ul>
<p>这种机制让 C++ 在泛型编程中具备了强大的类型适配能力。</p>
<p>requires可以用concept封装一下，这样可以提高可读性和复用性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> ConvertCC = std::is_convertible_v&lt;std::<span class="type">decay_t</span>&lt;T&gt;, std::<span class="type">decay_t</span>&lt;U&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> VarExprCC = std::is_same_v&lt;T, VarExpr&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="性能压力测试"><a href="#性能压力测试" class="headerlink" title="性能压力测试"></a>性能压力测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProcessedData</span> &#123;</span><br><span class="line">    std::string info;</span><br><span class="line">    <span class="type">int</span> checksum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, StressTest) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> reaction;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create var-data sources</span></span><br><span class="line">    <span class="keyword">auto</span> base1 = <span class="built_in">var</span>(<span class="number">1</span>);                <span class="comment">// Integer source</span></span><br><span class="line">    <span class="keyword">auto</span> base2 = <span class="built_in">var</span>(<span class="number">2.0</span>);              <span class="comment">// Double source</span></span><br><span class="line">    <span class="keyword">auto</span> base3 = <span class="built_in">var</span>(<span class="literal">true</span>);             <span class="comment">// Boolean source</span></span><br><span class="line">    <span class="keyword">auto</span> base4 = <span class="built_in">var</span>(std::string&#123;<span class="string">&quot;3&quot;</span>&#125;); <span class="comment">// String source</span></span><br><span class="line">    <span class="keyword">auto</span> base5 = <span class="built_in">var</span>(<span class="number">4</span>);                <span class="comment">// Integer source</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 1: Add integer and double</span></span><br><span class="line">    <span class="keyword">auto</span> layer1 = <span class="built_in">calc</span>([](<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;, base1, base2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 2: Multiply or divide based on the flag</span></span><br><span class="line">    <span class="keyword">auto</span> layer2 = <span class="built_in">calc</span>([](<span class="type">double</span> val, <span class="type">bool</span> flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag ? val * <span class="number">2</span> : val / <span class="number">2</span>;</span><br><span class="line">    &#125;, layer1, base3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 3: Convert double value to a string</span></span><br><span class="line">    <span class="keyword">auto</span> layer3 = <span class="built_in">calc</span>([](<span class="type">double</span> val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Value:&quot;</span> + std::<span class="built_in">to_string</span>(val);</span><br><span class="line">    &#125;, layer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 4: Append integer to string</span></span><br><span class="line">    <span class="keyword">auto</span> layer4 = <span class="built_in">calc</span>([](<span class="type">const</span> std::string &amp;s, <span class="type">const</span> std::string &amp;s4) &#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;_&quot;</span> + s4;</span><br><span class="line">    &#125;, layer3, base4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 5: Get the length of the string</span></span><br><span class="line">    <span class="keyword">auto</span> layer5 = <span class="built_in">calc</span>([](<span class="type">const</span> std::string &amp;s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">length</span>();</span><br><span class="line">    &#125;, layer4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 6: Create a vector of double values</span></span><br><span class="line">    <span class="keyword">auto</span> layer6 = <span class="built_in">calc</span>([](<span class="type">size_t</span> len, <span class="type">int</span> b5) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len, b5);</span><br><span class="line">    &#125;, layer5, base5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 7: Sum all elements in the vector</span></span><br><span class="line">    <span class="keyword">auto</span> layer7 = <span class="built_in">calc</span>([](<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;, layer6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 8: Create a ProcessedData object with checksum and info</span></span><br><span class="line">    <span class="keyword">auto</span> layer8 = <span class="built_in">calc</span>([](<span class="type">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessedData&#123;<span class="string">&quot;ProcessedData&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(sum)&#125;;</span><br><span class="line">    &#125;, layer7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 9: Combine info and checksum into a string</span></span><br><span class="line">    <span class="keyword">auto</span> layer9 = <span class="built_in">calc</span>([](<span class="type">const</span> ProcessedData &amp;calc) &#123;</span><br><span class="line">        <span class="keyword">return</span> calc.info + <span class="string">&quot;|&quot;</span> + std::<span class="built_in">to_string</span>(calc.checksum);</span><br><span class="line">    &#125;, layer8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Final layer: Add &quot;Final:&quot; prefix to the result</span></span><br><span class="line">    <span class="keyword">auto</span> finalLayer = <span class="built_in">calc</span>([](<span class="type">const</span> std::string &amp;s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Final:&quot;</span> + s;</span><br><span class="line">    &#125;, layer9);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ITERATIONS = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">auto</span> start = steady_clock::<span class="built_in">now</span>(); <span class="comment">// Start measuring time</span></span><br><span class="line">    <span class="comment">// Perform stress test for the given number of iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; ++i) &#123;</span><br><span class="line">        <span class="comment">// Update base sources with new values</span></span><br><span class="line">        *base1 = i % <span class="number">100</span>;</span><br><span class="line">        *base2 = (i % <span class="number">100</span>) * <span class="number">0.1</span>;</span><br><span class="line">        *base3 = i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the expected result for the given input</span></span><br><span class="line">        std::string expected = [&amp;]() &#123;</span><br><span class="line">            <span class="type">double</span> l1 = base<span class="number">1.</span><span class="built_in">get</span>() + base<span class="number">2.</span><span class="built_in">get</span>();                        <span class="comment">// Add base1 and base2</span></span><br><span class="line">            <span class="type">double</span> l2 = base<span class="number">3.</span><span class="built_in">get</span>() ? l1 * <span class="number">2</span> : l1 / <span class="number">2</span>;                    <span class="comment">// Multiply or divide based on base3</span></span><br><span class="line">            std::string l3 = <span class="string">&quot;Value:&quot;</span> + std::<span class="built_in">to_string</span>(l2);               <span class="comment">// Convert to string</span></span><br><span class="line">            std::string l4 = l3 + <span class="string">&quot;_&quot;</span> + base<span class="number">4.</span><span class="built_in">get</span>();                      <span class="comment">// Append base1</span></span><br><span class="line">            <span class="type">size_t</span> l5 = l<span class="number">4.l</span>ength();                                      <span class="comment">// Get string length</span></span><br><span class="line">            <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">l6</span><span class="params">(l5, base<span class="number">5.</span>get())</span></span>;                         <span class="comment">// Create vector of length &#x27;l5&#x27;</span></span><br><span class="line">            <span class="type">int</span> l7 = std::<span class="built_in">accumulate</span>(l<span class="number">6.</span><span class="built_in">begin</span>(), l<span class="number">6.</span><span class="built_in">end</span>(), <span class="number">0</span>);            <span class="comment">// Sum vector values</span></span><br><span class="line">            ProcessedData l8&#123;<span class="string">&quot;ProcessedData&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(l7)&#125;;      <span class="comment">// Create ProcessedData object</span></span><br><span class="line">            std::string l9 = l<span class="number">8.</span>info + <span class="string">&quot;|&quot;</span> + std::<span class="built_in">to_string</span>(l<span class="number">8.</span>checksum); <span class="comment">// Combine info and checksum</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Final:&quot;</span> + l9;                                         <span class="comment">// Add final prefix</span></span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print progress every 10,000 iterations</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span> &amp;&amp; finalLayer.<span class="built_in">get</span>() == expected) &#123;</span><br><span class="line">            <span class="keyword">auto</span> dur = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(steady_clock::<span class="built_in">now</span>() - start);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Progress: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; ITERATIONS</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; dur.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms)\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output the final results of the stress test</span></span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(steady_clock::<span class="built_in">now</span>() - start);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=== Stress Test Results ===\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Iterations: &quot;</span> &lt;&lt; ITERATIONS &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Total time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Avg time per update: &quot;</span></span><br><span class="line">              &lt;&lt; duration.<span class="built_in">count</span>() / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(ITERATIONS) &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::function实现类型擦除：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt; &amp;f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_observers.<span class="built_in">emplace_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateObservers</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt; &amp;f, Args &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        (..., args.<span class="built_in">addObserver</span>(f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;observer : m_observers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">observer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; m_observers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B5%B7%E6%9D%A5%EF%BC%81%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cm9trkbhx0000psky87dv5oet" data-title="第二章：让数据流起来！依赖节点管理的实现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第一章：让代码跑起来！构建响应式框架的起点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A9%E4%BB%A3%E7%A0%81%E8%B7%91%E8%B5%B7%E6%9D%A5%EF%BC%81%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B5%B7%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2025-04-12T15:03:53.216Z" itemprop="datePublished">2025-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A9%E4%BB%A3%E7%A0%81%E8%B7%91%E8%B5%B7%E6%9D%A5%EF%BC%81%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B5%B7%E7%82%B9/">第一章：让代码跑起来！构建响应式框架的起点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第一章：让代码跑起来！构建响应式框架的起点"><a href="#第一章：让代码跑起来！构建响应式框架的起点" class="headerlink" title="第一章：让代码跑起来！构建响应式框架的起点"></a>第一章：让代码跑起来！构建响应式框架的起点</h1><p>在本章中，我们将从零开始搭建 Reaction 响应式框架的基本工程结构，并实现几个关键的核心组件：<code>DataSource</code>、<code>Expression</code> 和 <code>Resource</code>。这些组件将构成我们响应式框架的计算骨架。</p>
<p>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(a.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line"><span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(dsds); &#125;, a, ds);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;14.140000&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="1-项目结构搭建"><a href="#1-项目结构搭建" class="headerlink" title="1. 项目结构搭建"></a>1. 项目结构搭建</h2><p>使用 CMake 构建项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reaction/</span><br><span class="line">├── include/</span><br><span class="line">│   └── reaction/</span><br><span class="line">│       ├── dataSource.h</span><br><span class="line">│       ├── expression.h</span><br><span class="line">│       └── resource.h</span><br><span class="line">├── test/</span><br><span class="line">│   └── test.cpp</span><br><span class="line">├── CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="1-1-CMakeLists-txt-示例"><a href="#1-1-CMakeLists-txt-示例" class="headerlink" title="1.1 CMakeLists.txt 示例"></a>1.1 CMakeLists.txt 示例</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(reaction VERSION <span class="number">1.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(/W4 /GR-)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_compile_options</span>(-Wall -Wextra -pedantic -fno-rtti -std=c++<span class="number">2</span>a)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Choose the type of build.&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> INTERFACE)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>::<span class="variable">$&#123;PROJECT_NAME&#125;</span> ALIAS <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> INTERFACE</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(GTest)</span><br><span class="line"><span class="keyword">if</span>(GTest_FOUND)</span><br><span class="line">    <span class="keyword">enable_testing</span>()</span><br><span class="line">    <span class="keyword">file</span>(GLOB TEST_SOURCES <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>/*.cpp)</span><br><span class="line">    <span class="keyword">add_executable</span>(runTests <span class="variable">$&#123;TEST_SOURCES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(runTests PRIVATE GTest::GTest GTest::Main <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">add_test</span>(NAME reactionTest <span class="keyword">COMMAND</span> runTests)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;GTest not found, skipping tests.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MSVC (Windows)</strong>:<ul>
<li><code>/W4</code>: 高警告级别</li>
<li><code>/GR-</code>: 禁用 RTTI (运行时类型信息)</li>
</ul>
</li>
<li><strong>其他编译器</strong>:<ul>
<li><code>-Wall -Wextra -pedantic</code>: 严格警告</li>
<li><code>-fno-rtti</code>: 禁用 RTTI</li>
<li><code>-std=c++2a</code>: 指定 C++20 标准 (GCC&#x2F;Clang 的旧名称)</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> INTERFACE)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>::<span class="variable">$&#123;PROJECT_NAME&#125;</span> ALIAS <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个 INTERFACE 库 (不构建实际二进制文件)</li>
<li>为库创建别名，符合现代 CMake 目标命名规范</li>
</ul>
<hr>
<h2 id="2-实现核心组件"><a href="#2-实现核心组件" class="headerlink" title="2. 实现核心组件"></a>2. 实现核心组件</h2><h3 id="2-1-DataSource：数据源管理器"><a href="#2-1-DataSource：数据源管理器" class="headerlink" title="2.1 DataSource：数据源管理器"></a>2.1 DataSource：数据源管理器</h3><p><code>DataSource</code> 是用户操作响应式变量的入口，暴露出 <code>get()</code>等各种接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSource</span> : <span class="keyword">public</span> Expression&lt;T, Args...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getValue</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>为什么要采用这种继承的设计模式</strong></p>
</blockquote>
<ol>
<li>数据源本身是一个表达式，这里符合<strong>is-a</strong>的关系</li>
<li><strong>解耦逻辑</strong>，将不同类型的数据源的处理逻辑放在Expression类中处理，DataSource本身只负责用户交互的部分</li>
<li><strong>空基类优化（EBO）</strong><br> 当基类为空时（如只有类型定义无数据成员），继承可完全消除存储开销<br> 组合方式会因C++对象布局规则（每个对象必须有唯一地址）产生至少1个指针的开销</div></li>
</ol>
<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>为什么此处必须要 <code>this-&gt;getValue()</code>，否则编译不通过</strong></p>
</blockquote>
<p>要解释这个问题，首先要从 C++ 模板的编译机制说起——<br><strong>两阶段查找（Two-Phase Lookup）</strong> 和 <strong>延迟实例化（Delayed Instantiation）</strong> 机制：</p>
<hr>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">memberFunc</span>();  <span class="comment">// ✅ 编译通过（待决名）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设前面没有 IncompleteType 的定义</span></span><br><span class="line">    IncompleteType* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">memberFunc</span>();  <span class="comment">// ❌ 编译错误：</span></span><br><span class="line">                        <span class="comment">//    IncompleteType 是非待决名，且是不完整类型，无法调用成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>第一阶段（语法分析阶段）</strong></p>
<ul>
<li>编译器只检查模板本身的<strong>语法</strong>（如 <code>ptr-&gt;memberFunc()</code> 是否符合基本语法规则）。</li>
<li>不检查 <code>T</code> 是否完整，也不检查 <code>memberFunc</code> 是否存在（因为 <code>T</code> 可能是任何类型）。</li>
</ul>
</li>
<li><p><strong>第二阶段（模板实例化阶段）</strong></p>
<ul>
<li>当 <code>bar&lt;IncompleteType&gt;(ptr)</code> 被调用时，编译器尝试实例化 <code>bar</code>。</li>
<li>如果 <code>IncompleteType</code> 仍然不完整，或者没有 <code>memberFunc</code>，则实例化失败，报错。</li>
</ul>
</li>
</ol>
<p>在模板中，如果一个名称（变量、函数、类型等）的解析<strong>依赖于模板参数</strong>，则称为 <strong>待决名（Dependent Name）</strong>。<br>编译器在第一阶段（模板定义阶段）不会立即解析它，而是在第二阶段（模板实例化阶段）再确定其含义。</p>
<hr>
<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunc</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memberFunc</span>();       <span class="comment">// ❌ 非待决名，立即查找失败</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">memberFunc</span>(); <span class="comment">// ✅ 待决名，延迟到实例化阶段再查找</span></span><br><span class="line">        Base&lt;T&gt;::<span class="built_in">memberFunc</span>(); <span class="comment">//  另一种正确写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>memberFunc()</code></strong></p>
<ul>
<li>由于不依赖任何模板参数，被视为<strong>非待决名</strong>，会在编译时的语义分析阶段立即查找。</li>
<li>此时 <code>Base&lt;T&gt;</code> 尚未实例化，查找失败，编译报错。</li>
</ul>
</li>
<li><p><strong><code>this-&gt;memberFunc()</code></strong></p>
<ul>
<li>等价于 <code>MyClass&lt;T&gt; * -&gt; memberFunc()</code>，依赖于模板类型参数 <code>T</code>，属于<strong>待决名</strong>。</li>
<li>编译器在实例化 <code>MyClass&lt;T&gt;</code> 时，再去查找 <code>memberFunc()</code>，此时 <code>Base&lt;T&gt;</code> 已实例化，可正常调用。</li>
</ul>
</li>
</ul>
</div>

<h3 id="2-2-Expression：表达式封装器"><a href="#2-2-Expression：表达式封装器" class="headerlink" title="2.2 Expression：表达式封装器"></a>2.2 Expression：表达式封装器</h3><p>用于管理依赖计算逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExpressionTraits</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExpressionTraits</span>&lt;DataSource&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExpressionTraits</span>&lt;DataSource&lt;Fun, Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = std::<span class="type">invoke_result_t</span>&lt;Fun, <span class="keyword">typename</span> ExpressionTraits&lt;Args&gt;::Type...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> ExpressionTraits&lt;DataSource&lt;Fun, Args...&gt;&gt;::Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> : <span class="keyword">public</span> Resource&lt;ReturnType&lt;Fun, Args...&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... A&gt;</span><br><span class="line">    <span class="built_in">Expression</span>(F &amp;&amp;f, A &amp;&amp;...args) : <span class="built_in">m_func</span>(std::forward&lt;F&gt;(f)), <span class="built_in">m_args</span>(std::forward&lt;Args&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">evaluate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> result = [&amp;]&lt;std::<span class="type">size_t</span>... I&gt;(std::index_sequence&lt;I...&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">invoke</span>(m_func, std::<span class="built_in">get</span>&lt;I&gt;(m_args).<span class="built_in">get</span>()...);</span><br><span class="line">        &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(m_args)&gt;&gt;&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">updateValue</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Fun m_func;</span><br><span class="line">    std::tuple&lt;Args...&gt; m_args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span>&lt;Type&gt; : <span class="keyword">public</span> Resource&lt;Type&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Expression</span>(T &amp;&amp;t) : <span class="built_in">Resource</span>&lt;Type&gt;(std::forward&lt;T&gt;(t)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using Resource&lt;Type&gt;::Resource; //或者用C++11的继承构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>std::invoke_result_t</code>有个坑，我们后面会修改它</p>
</blockquote>
<blockquote>
<p>使用了 C++20 的 lambda 模板参数<code>[&amp;]&lt;std::size_t... I&gt;(...)</code>，这种语法被称为 “immediate lambda”</p>
</blockquote>
<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>为什么类模板的类型参数不能是万能引用</strong></p>
</blockquote>
<p>我学习现代C++的时候，思考过这个问题，函数模板和类模板既然都可以推导，为什么函数模板可以引用折叠推导为万能引用，而类模板不行？</p>
<p><strong>函数模板参数推导（Function Template Argument Deduction）（C++98就已经支持）</strong><br><strong>类模板参数推导（CTAD, Class Template Argument Deduction）（C++17才开始支持）</strong></p>
<p><strong>为什么CTAD需要单独引入？</strong><br><strong>技术复杂度不同</strong>：</p>
<ul>
<li>函数模板推导仅涉及单次调用</li>
<li>类模板推导需要协调所有构造函数的参数组合（需要Deduction Guides）</li>
</ul>
<p><strong>如果允许类模板参数直接作为万能引用</strong>，会导致哪些严重的类型安全问题和技术陷阱。</p>
<p>假设C++允许这样的语法（实际非法）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DangerousHolder</span> &#123;</span><br><span class="line">    T resource;  <span class="comment">// 成员是引用类型（可能是左值或右值引用）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DangerousHolder</span>(T&amp;&amp; r) : <span class="built_in">resource</span>(std::forward&lt;T&gt;(r)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="类型系统崩溃"><a href="#类型系统崩溃" class="headerlink" title="类型系统崩溃"></a>类型系统崩溃</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例2：类型意外变为引用</span></span><br><span class="line"><span class="function">DangerousHolder <span class="title">holder1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 假设T=int，则成员类型为int&amp;&amp;</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function">DangerousHolder <span class="title">holder2</span><span class="params">(x)</span></span>;     <span class="comment">// 假设T=int&amp;，则成员类型为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(holder<span class="number">1.</span>resource), <span class="type">int</span>&amp;&amp;&gt;); <span class="comment">// 通过</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(holder<span class="number">2.</span>resource), <span class="type">int</span>&amp;&gt;);  <span class="comment">// 通过</span></span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>相同模板实例化<code>DangerousHolder&lt;int&gt;</code>会产生<strong>两种完全不同的成员类型</strong></li>
<li>违反类模板”生成确定类型”的基本原则</li>
</ul>
<p><strong>对比安全实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SafeHolder&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 成员永远是int类型</span></span><br><span class="line"><span class="function">SafeHolder&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(x)</span></span>;   <span class="comment">// 同上，即使传入左值</span></span><br></pre></td></tr></table></figure>

<p>引用折叠规则不适合贯穿整个对象生命周期：</p>
<p><strong>C++ 的引用折叠规则（&amp; &amp; → &amp;、&amp;&amp; &amp; → &amp;、&amp;&amp; &amp;&amp; → &amp;&amp; 等）设计初衷是为了函数参数推导时临时使用。<br>如果把它用到类模板参数层面，就得让编译器在模板定义、实例化、特化时都执行复杂的折叠，极易引入混乱和歧义。</strong></p>
<hr>
<p>而函数模板的万能引用之所以能避免类模板参数的问题，关键在于其<strong>临时性</strong>和<strong>作用域局限性</strong>。这种设计差异源于两者在C++中的根本角色不同。以下是具体分析：</p>
<h4 id="核心差异：生存周期与作用域"><a href="#核心差异：生存周期与作用域" class="headerlink" title="核心差异：生存周期与作用域"></a>核心差异：生存周期与作用域</h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>函数模板万能引用</th>
<th>类模板成员引用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用时间</strong></td>
<td>仅在函数调用期间有效</td>
<td>伴随整个对象生命周期</td>
</tr>
<tr>
<td><strong>存储要求</strong></td>
<td>不涉及长期存储</td>
<td>可能成为对象状态的一部分</td>
</tr>
<tr>
<td><strong>类型确定性</strong></td>
<td>每次调用独立推导</td>
<td>必须与类定义统一</td>
</tr>
</tbody></table>
<h4 id="1-无法形成长期持有"><a href="#1-无法形成长期持有" class="headerlink" title="1. 无法形成长期持有"></a>1. 无法形成长期持有</h4><p><strong>临时性与作用域限制</strong></p>
<ul>
<li>函数内部传入的右值或左值引用，只在函数执行期间存在，之后立即销毁或恢复。</li>
<li>类成员一旦持有引用，就要长期管理它的生命周期，容易出错。</li>
</ul>
<h4 id="2-类型推导隔离性"><a href="#2-类型推导隔离性" class="headerlink" title="2. 类型推导隔离性"></a>2. 类型推导隔离性</h4><p><strong>推导隔离性</strong></p>
<ul>
<li>每次函数调用都是独立的模板推导：<code>foo(x)</code> 和 <code>foo(3.14)</code> 分别会推导为 <code>T=int&amp;</code> 和 <code>T=double</code>，互不影响。</li>
<li>类模板在同一次实例化内，必须保证“相同模板参数→相同类型布局”，否则就打破了类型安全。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">foo</span>(x);     <span class="comment">// 本次T=int&amp;</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">3.14</span>);  <span class="comment">// 本次T=double</span></span><br></pre></td></tr></table></figure>

<p>不会出现类模板中”一个实例化对应多种成员类型”的矛盾</p>
<ul>
<li>函数模板和类模板服务于不同场景：函数模板强调“临时、一次性”的推导与转发；类模板强调“持久、稳定”的类型定义。</li>
<li>语言设计者为了保证语法简洁、一致、可维护，特意将“引用折叠”机制局限在了函数模板参数中，不允许在类模板参数列表出现。</li>
</ul>
</div>


<h3 id="2-3-Resource：值资源管理器"><a href="#2-3-Resource：值资源管理器" class="headerlink" title="2.3 Resource：值资源管理器"></a>2.3 Resource：值资源管理器</h3><p>用于底层数据的读写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ResourceBase</span>() :</span><br><span class="line">        <span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">ResourceBase</span>(T &amp;&amp;t) :</span><br><span class="line">        <span class="built_in">m_ptr</span>(std::<span class="built_in">make_unique</span>&lt;Type&gt;(std::forward&lt;T&gt;(t))) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ptr) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Attempt to get a null pointer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateValue</span><span class="params">(T &amp;&amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ptr) &#123;</span><br><span class="line">            m_ptr = std::<span class="built_in">make_unique</span>&lt;Type&gt;(std::forward&lt;T&gt;(t));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *m_ptr = std::forward&lt;T&gt;(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique&lt;Type&gt; m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>八股文整理：为什么要make_shared, make_unique而不直接使用构造函数</strong></p>
</blockquote>
<p>在 C++ 中，<code>std::make_shared</code> 和 <code>std::make_unique</code> 是创建智能指针的推荐方式，相较于直接使用构造函数（如 <code>std::shared_ptr&lt;T&gt;(new T)</code> 或 <code>std::unique_ptr&lt;T&gt;(new T)</code>），它们具有以下优势：</p>
<hr>
<h4 id="1-代码简洁性"><a href="#1-代码简洁性" class="headerlink" title="1. 代码简洁性"></a>1. <strong>代码简洁性</strong></h4><ul>
<li><code>make_shared</code> 和 <code>make_unique</code> 通过模板参数推导，允许<strong>一行代码完成对象的构造和智能指针的初始化</strong>，避免重复书写类型。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = std::<span class="built_in">make_shared</span>&lt;Foo&gt;();  <span class="comment">// 简洁</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Foo&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;    <span class="comment">// 需要重复写 Foo</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-异常安全"><a href="#2-异常安全" class="headerlink" title="2. 异常安全"></a>2. <strong>异常安全</strong></h4><ul>
<li>如果直接使用 <code>new</code> 并将裸指针传递给智能指针构造函数，可能在<strong>内存分配成功但智能指针构造未完成时</strong>发生异常，导致内存泄漏。</li>
<li><code>make_shared</code> 和 <code>make_unique</code> 是<strong>原子操作</strong>（分配内存和构造智能指针），避免了这一问题。</li>
<li>示例（不安全的情况）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">shared_ptr</span>&lt;Foo&gt;(<span class="keyword">new</span> <span class="built_in">Foo</span>(arg1, arg2)); <span class="comment">// 可能泄漏</span></span><br></pre></td></tr></table></figure>
改用 <code>make_shared</code> 后：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;Foo&gt;(arg1, arg2); <span class="comment">// 更安全</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-性能优化（仅针对-make-shared）"><a href="#3-性能优化（仅针对-make-shared）" class="headerlink" title="3. 性能优化（仅针对 make_shared）"></a>3. <strong>性能优化（仅针对 <code>make_shared</code>）</strong></h4><ul>
<li><code>std::shared_ptr</code> 需要维护两块内存：<ol>
<li><strong>对象本身的内存</strong>（存储 <code>Foo</code> 的数据）。</li>
<li><strong>控制块的内存</strong>（存储引用计数、弱计数等）。</li>
</ol>
</li>
<li>直接使用 <code>new</code> 时，这两块内存是<strong>分开分配</strong>的（两次内存操作）。</li>
<li><code>make_shared</code> 会<strong>合并这两块内存</strong>，通过单次分配完成，减少了内存开销和分配时间。</div></li>
</ul>
<hr>
<h2 id="3-封装-API：reaction-var-和-reaction-calc"><a href="#3-封装-API：reaction-var-和-reaction-calc" class="headerlink" title="3. 封装 API：reaction::var 和 reaction::calc"></a>3. 封装 API：reaction::var 和 reaction::calc</h2><p>为了方便用户使用，我们提供统一入口函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> reaction &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">var</span><span class="params">(T &amp;&amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DataSource</span>&lt;T&gt;(std::forward&lt;T&gt;(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">calc</span><span class="params">(F f, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DataSource&lt;std::<span class="type">decay_t</span>&lt;F&gt;, std::<span class="type">decay_t</span>&lt;Args&gt;...&gt;(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意这里的<code>decay_t</code>，类模板应该生成常规类型（regular types），而引用类型会破坏值语义的完整性，影响后面的类型推导、特化</strong></p>
</blockquote>
<hr>
<h2 id="4-编写测试：test-test-var-cpp"><a href="#4-编写测试：test-test-var-cpp" class="headerlink" title="4. 编写测试：test&#x2F;test_var.cpp"></a>4. 编写测试：test&#x2F;test_var.cpp</h2><p>我们用 GTest 验证功能是否正常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reaction/dataSource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestCalc) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(a.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(dsds); &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;14.140000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>通过本章内容，我们实现了 Reaction 框架的第一个可运行版本，包括基本的数据源管理、表达式求值和测试验证，下一章我们开始实现数据源的依赖传播</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A9%E4%BB%A3%E7%A0%81%E8%B7%91%E8%B5%B7%E6%9D%A5%EF%BC%81%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B5%B7%E7%82%B9/" data-id="cm9slj60o0000uokyf4nm8879" data-title="第一章：让代码跑起来！构建响应式框架的起点" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Reaction响应式框架介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/12/Reaction%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2025-04-12T13:05:45.491Z" itemprop="datePublished">2025-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/12/Reaction%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/">从零实现响应式框架——基本概念和设计思路</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="走进响应式编程：从理念到-C-20-实现-——-Reaction-响应式框架介绍"><a href="#走进响应式编程：从理念到-C-20-实现-——-Reaction-响应式框架介绍" class="headerlink" title="走进响应式编程：从理念到 C++20 实现 —— Reaction 响应式框架介绍"></a>走进响应式编程：从理念到 C++20 实现 —— Reaction 响应式框架介绍</h1><p>在现代软件开发中，响应式编程正逐步成为构建数据驱动应用的重要范式。本文将带你深入了解响应式编程的核心理念，比较当前主流响应式框架的优劣，并探讨为何在 C++20 环境下实现响应式框架尤为必要。随后，我们将介绍 Reaction 框架的整体设计思路与架构布局。</p>
<hr>
<h2 id="🎯-本教程面向谁？"><a href="#🎯-本教程面向谁？" class="headerlink" title="🎯 本教程面向谁？"></a>🎯 本教程面向谁？</h2><p>本教程适合以下人群阅读：</p>
<ul>
<li><strong>具备 C++ 基础的开发者</strong>：希望通过实战提升对语言本身的理解，掌握更现代的 C++20 编程范式。</li>
<li><strong>对现代 C++ 感兴趣的学习者</strong>：希望学习 Concepts、constexpr、模板元编程等特性在工程中的实际用法。</li>
<li><strong>正在求职或准备面试的 C++ 开发者</strong>：通过构建完整框架提升项目能力，积累可展示的实战经验。</li>
<li><strong>希望了解响应式编程原理的人</strong>：尤其是在 Vue、React 等前端框架中有相关经验，想了解背后机制在 C++ 中的实现方式。</li>
</ul>
<p>如果你希望从零构建一个现代化、类型安全、高性能的响应式框架，那么这份系列教程将为你提供系统的思路与代码支撑。</p>
<hr>
<h2 id="1-什么是响应式编程？"><a href="#1-什么是响应式编程？" class="headerlink" title="1. 什么是响应式编程？"></a>1. 什么是响应式编程？</h2><p>响应式编程是一种以“数据驱动视图”和“自动更新”为核心的编程范式。其目标是当底层数据发生变化时，系统能够自动刷新所有依赖于该数据的部分，从而避免繁琐的手动更新逻辑，提升系统的实时性、稳定性和维护性。</p>
<h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul>
<li><p><strong>数据流（Data Flow）</strong><br>将数据视作一系列随时间变化的值流，当某个值更新时，其变化将自动传播到所有依赖者。</p>
</li>
<li><p><strong>依赖追踪（Dependency Tracking）</strong><br>系统自动记录数据之间的依赖关系，确保任何变化都能触发对应更新操作。</p>
</li>
<li><p><strong>声明式编程（Declarative Programming）</strong><br>开发者只需声明“数据之间的关系”，而不必显式编写“如何更新”的逻辑，框架会自动完成这些工作。</p>
</li>
</ul>
<hr>
<h2 id="2-主流响应式框架对比分析"><a href="#2-主流响应式框架对比分析" class="headerlink" title="2. 主流响应式框架对比分析"></a>2. 主流响应式框架对比分析</h2><p>目前在不同编程语言生态中，已经诞生了众多响应式框架。它们各具特色，覆盖前端开发、后端服务乃至系统编程领域。</p>
<h3 id="2-1-JavaScript-TypeScript-生态"><a href="#2-1-JavaScript-TypeScript-生态" class="headerlink" title="2.1 JavaScript &#x2F; TypeScript 生态"></a>2.1 JavaScript &#x2F; TypeScript 生态</h3><ul>
<li><p><strong>RxJS</strong></p>
<ul>
<li>优点：操作符丰富，支持异步流组合，适合事件密集型场景。</li>
<li>缺点：学习曲线陡峭，操作链复杂，调试困难。</li>
</ul>
</li>
<li><p><strong>Vue.js &#x2F; React</strong></p>
<ul>
<li>优点：通过响应式状态管理实现 UI 自动更新，极大简化前端开发。</li>
<li>缺点：响应机制封装较深，底层调试不易。</li>
</ul>
</li>
</ul>
<h3 id="2-2-Java-生态"><a href="#2-2-Java-生态" class="headerlink" title="2.2 Java 生态"></a>2.2 Java 生态</h3><ul>
<li><strong>Reactor &#x2F; RxJava</strong><ul>
<li>优点：强大的流处理能力，适用于高并发和分布式系统。</li>
<li>缺点：设计复杂，资源消耗较大，学习成本高。</li>
</ul>
</li>
</ul>
<h3 id="2-3-C-生态"><a href="#2-3-C-生态" class="headerlink" title="2.3 C# 生态"></a>2.3 C# 生态</h3><ul>
<li><strong>Rx.NET</strong><ul>
<li>优点：集成度高、语法简洁，非常适合异步编程。</li>
<li>缺点：内存管理需谨慎，性能上不及底层语言。</li>
</ul>
</li>
</ul>
<h3 id="2-4-C-生态"><a href="#2-4-C-生态" class="headerlink" title="2.4 C++ 生态"></a>2.4 C++ 生态</h3><ul>
<li><p><strong>RxCpp</strong></p>
<ul>
<li>优点：API 接近 Rx 系列设计，功能完备，支持复杂流式操作。</li>
<li>缺点：语法冗长、模板嵌套复杂，难以在简洁场景中高效应用。</li>
</ul>
</li>
<li><p><strong>其他尝试性库（如 Bacon++）</strong></p>
<ul>
<li>优点：探索性设计，验证响应式模型在 C++ 中的可行性。</li>
<li>缺点：社区活跃度低，文档不足，稳定性待提升。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-为什么选择-C-20-来实现响应式框架？"><a href="#3-为什么选择-C-20-来实现响应式框架？" class="headerlink" title="3. 为什么选择 C++20 来实现响应式框架？"></a>3. 为什么选择 C++20 来实现响应式框架？</h2><p>C++20 带来了诸多颠覆性特性，为响应式框架的高效实现奠定了基础：</p>
<ul>
<li><p><strong>Concepts 与 constexpr</strong><br>强类型约束和编译期计算能力显著增强，使得类型安全与性能优化并存。</p>
</li>
<li><p><strong>模板元编程能力增强</strong><br>支持更强大的编译期逻辑，能够构建“零运行时成本”的依赖追踪机制。</p>
</li>
<li><p><strong>模块化支持</strong><br>提高项目结构清晰度，减少编译依赖与时间成本，有助于大规模架构设计。</p>
</li>
</ul>
<p>借助这些新特性，我们可以打造一个编译期友好、性能卓越、类型安全的响应式框架，填补 C++ 生态在 UI 状态管理和数据依赖表达方面的空白。</p>
<hr>
<h2 id="4-Reaction-响应式框架-——-设计理念与结构"><a href="#4-Reaction-响应式框架-——-设计理念与结构" class="headerlink" title="4. Reaction 响应式框架 —— 设计理念与结构"></a>4. Reaction 响应式框架 —— 设计理念与结构</h2><p>Reaction is a blazing-fast, modern C++20 header-only reactive framework that brings React&#x2F;Vue-style dataflow to native C++ – perfect for UI, game logic, and more.</p>
<h3 id="🎯-Focused-on-UI-Dataflow-Management"><a href="#🎯-Focused-on-UI-Dataflow-Management" class="headerlink" title="🎯 Focused on UI Dataflow Management"></a>🎯 <strong>Focused on UI Dataflow Management</strong></h3><ul>
<li><strong>Pure Data-Driven Updates</strong> – Optimized for <strong>one-way binding</strong> (Model → View)</li>
<li><strong>No Event Emitters</strong> – Changes propagate <strong>only through data dependencies</strong>, avoiding callback hell</li>
<li><strong>Predictable Updates</strong> – Strict <strong>top-down dataflow</strong> like React&#x2F;Vue, but with zero runtime overhead</li>
</ul>
<h4 id="Ideal-For"><a href="#Ideal-For" class="headerlink" title="Ideal For:"></a><strong>Ideal For:</strong></h4><p>✅ <strong>MVVM&#x2F;MVC UI Architectures</strong><br>✅ <strong>Game Object Properties</strong><br>✅ <strong>Form Validation Chains</strong><br>✅ <strong>Animation State Machines</strong></p>
<h3 id="🚀-Performance-Optimized"><a href="#🚀-Performance-Optimized" class="headerlink" title="🚀 Performance Optimized"></a>🚀 Performance Optimized</h3><ul>
<li><strong>Zero-cost abstractions</strong> through template metaprogramming</li>
<li>Minimal runtime overhead with <strong>smart change propagation</strong></li>
<li>Propagation efficiency <strong>at the level of millions per second</strong></li>
</ul>
<h3 id="🔗-Intelligent-Dependency-Management"><a href="#🔗-Intelligent-Dependency-Management" class="headerlink" title="🔗 Intelligent Dependency Management"></a>🔗 Intelligent Dependency Management</h3><ul>
<li>Automatic <strong>DAG detection</strong> and cycle prevention</li>
<li>Fine-grained <strong>change propagation control</strong></li>
<li>Configurable <strong>caching strategies</strong></li>
</ul>
<h3 id="🛡️-Safety-Guarantees"><a href="#🛡️-Safety-Guarantees" class="headerlink" title="🛡️ Safety Guarantees"></a>🛡️ Safety Guarantees</h3><ul>
<li>Compile-time <strong>type checking</strong> with C++20 concepts</li>
<li>Safe <strong>value semantics</strong> throughout the framework</li>
<li>Framework manages object lifetime internally</li>
</ul>
<h3 id="🧩-Extensible-Design"><a href="#🧩-Extensible-Design" class="headerlink" title="🧩 Extensible Design"></a>🧩 Extensible Design</h3><table>
<thead>
<tr>
<th>Feature</th>
<th>Options</th>
</tr>
</thead>
<tbody><tr>
<td>Trigger Policy</td>
<td>ValueChange, Threshold, Timer, Custom</td>
</tr>
<tr>
<td>Invalidation</td>
<td>Direct, KeepCalculate, LastValue</td>
</tr>
</tbody></table>
<h3 id="📦-Requirements"><a href="#📦-Requirements" class="headerlink" title="📦 Requirements"></a>📦 Requirements</h3><ul>
<li><strong>Compiler</strong>: C++20 compatible (GCC 10+, Clang 12+, MSVC 19.30+)</li>
<li><strong>Build System</strong>: CMake 3.15+</li>
</ul>
<h2 id="🛠-Installation"><a href="#🛠-Installation" class="headerlink" title="🛠 Installation"></a>🛠 Installation</h2><p>To build and install the <code>reaction</code> reactive framework, follow the steps below:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lumia431/reaction.git &amp;&amp; <span class="built_in">cd</span> reaction</span><br><span class="line">cmake -B build</span><br><span class="line">cmake --build build/</span><br><span class="line">cmake --install build/ --prefix /your/install/path</span><br></pre></td></tr></table></figure>

<p>After installation, you can include and link against reaction in your own CMake-based project:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(reaction REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE reaction)</span><br></pre></td></tr></table></figure>

<h3 id="🚀-Quick-Start"><a href="#🚀-Quick-Start" class="headerlink" title="🚀 Quick Start"></a>🚀 Quick Start</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reaction/reaction.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> reaction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Reactive variables for stock prices</span></span><br><span class="line">    <span class="keyword">auto</span> buyPrice = <span class="built_in">var</span>(<span class="number">100.0</span>);      <span class="comment">// Price at which stock was bought</span></span><br><span class="line">    <span class="keyword">auto</span> currentPrice = <span class="built_in">var</span>(<span class="number">105.0</span>);  <span class="comment">// Current market price</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Use &#x27;calc&#x27; to compute profit or loss amount</span></span><br><span class="line">    <span class="keyword">auto</span> profit = <span class="built_in">calc</span>([&amp;]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">currentPrice</span>() - <span class="built_in">buyPrice</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Use &#x27;expr&#x27; to compute percentage gain/loss</span></span><br><span class="line">    <span class="keyword">auto</span> profitPercent = <span class="built_in">expr</span>(std::<span class="built_in">abs</span>(currentPrice - buyPrice) / buyPrice * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Use &#x27;action&#x27; to print the log whenever values change</span></span><br><span class="line">    <span class="keyword">auto</span> logger = <span class="built_in">action</span>([&amp;]() &#123;</span><br><span class="line">        std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Stock Update] Current Price: $&quot;</span> &lt;&lt; <span class="built_in">currentPrice</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Profit: $&quot;</span> &lt;&lt; <span class="built_in">profit</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; <span class="built_in">profitPercent</span>() &lt;&lt; <span class="string">&quot;%)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simulate price changes</span></span><br><span class="line">    currentPrice.<span class="built_in">value</span>(<span class="number">110.0</span>).<span class="built_in">value</span>(<span class="number">95.0</span>);  <span class="comment">// Stock price increases</span></span><br><span class="line">    *buyPrice = <span class="number">90.0</span>;                       <span class="comment">// Buy price adjusted</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📖-Basic-Usage"><a href="#📖-Basic-Usage" class="headerlink" title="📖 Basic Usage"></a>📖 Basic Usage</h3><h4 id="1-Reactive-Variables-var"><a href="#1-Reactive-Variables-var" class="headerlink" title="1. Reactive Variables: var"></a>1. Reactive Variables: <code>var</code></h4><p>Define reactive state variables with <code>var&lt;T&gt;</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);         <span class="comment">// int variable</span></span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);      <span class="comment">// double variable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Method-style get value:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = a.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>brief way:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = <span class="built_in">a</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>Method-style assignment:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Pointer-style assignment:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-Derived-Computation-calc"><a href="#2-Derived-Computation-calc" class="headerlink" title="2. Derived Computation: calc"></a>2. Derived Computation: calc</h4><p>Use <strong>calc</strong> to create reactive computations based on one or more var instances.</p>
<ul>
<li>Lambda Capture Style:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">auto</span> sum = reaction::<span class="built_in">calc</span>([=]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">b</span>();  <span class="comment">// Retrieve current values using a() and b()</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Parameter Binding Style (High Performance):</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> bb) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(bb);</span><br><span class="line">&#125;, a, b);  <span class="comment">// Dependencies: a and b</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Declarative-Expression-expr"><a href="#3-Declarative-Expression-expr" class="headerlink" title="3. Declarative Expression: expr"></a>3. Declarative Expression: expr</h4><p>expr provides a clean and concise syntax to declare reactive expressions. The result automatically updates when any dependent variable changes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> result = reaction::<span class="built_in">expr</span>(a + b * <span class="number">3</span>);  <span class="comment">// result updates automatically when &#x27;a&#x27; or &#x27;b&#x27; change</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Reactive-Side-Effects-action"><a href="#4-Reactive-Side-Effects-action" class="headerlink" title="4. Reactive Side Effects: action"></a>4. Reactive Side Effects: action</h4><p>Register actions to perform side effects whenever the observed variables change.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> dds = reaction::<span class="built_in">action</span>([&amp;val]() &#123;</span><br><span class="line">    val = <span class="built_in">a</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Ofcourse, to get high performance can use Parameter Binding Style.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> dds = reaction::<span class="built_in">action</span>([&amp;val](<span class="keyword">auto</span> aa) &#123;</span><br><span class="line">    val = aa;</span><br><span class="line">&#125;, a);</span><br></pre></td></tr></table></figure>

<h4 id="5-Reactive-Struct-Fields-Field"><a href="#5-Reactive-Struct-Fields-Field" class="headerlink" title="5. Reactive Struct Fields: Field"></a>5. Reactive Struct Fields: <code>Field</code></h4><p>For complex types with reactive fields allow you to define struct-like variables whose members are individually reactive.</p>
<p>Here’s an example of a <code>PersonField</code> class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonField</span> : <span class="keyword">public</span> reaction::FieldBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PersonField</span>(std::string name, <span class="type">int</span> age):</span><br><span class="line">        <span class="built_in">m_name</span>(reaction::<span class="built_in">field</span>(<span class="keyword">this</span>, name)),</span><br><span class="line">        <span class="built_in">m_age</span>(reaction::<span class="built_in">field</span>(<span class="keyword">this</span>, age))&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name.<span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123; *m_name = name; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_age.<span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; *m_age = age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = reaction::<span class="built_in">var</span>(PersonField&#123;<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> action = reaction::<span class="built_in">action</span>(</span><br><span class="line">    []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Action Trigger , name = &quot;</span> &lt;&lt; <span class="built_in">p</span>().<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; age = &quot;</span> &lt;&lt; <span class="built_in">p</span>().<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">setName</span>(<span class="string">&quot;Jackson&quot;</span>); <span class="comment">// Action Trigger</span></span><br><span class="line">p-&gt;<span class="built_in">setAge</span>(<span class="number">28</span>);         <span class="comment">// Action Trigger</span></span><br></pre></td></tr></table></figure>

<h4 id="6-Copy-and-move-semantics-support"><a href="#6-Copy-and-move-semantics-support" class="headerlink" title="6. Copy and move semantics support"></a>6. Copy and move semantics support</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">b</span>(); &#125;);</span><br><span class="line"><span class="keyword">auto</span> ds_copy = ds;</span><br><span class="line"><span class="keyword">auto</span> ds_move = std::<span class="built_in">move</span>(ds);</span><br><span class="line"><span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(ds));</span><br></pre></td></tr></table></figure>

<h4 id="7-Resetting-Nodes-and-Dependencies"><a href="#7-Resetting-Nodes-and-Dependencies" class="headerlink" title="7. Resetting Nodes and Dependencies"></a>7. Resetting Nodes and Dependencies</h4><p>The reaction framework allows you to <strong>reset a computation node</strong> by replacing its computation function.<br>This mechanism is useful when the result needs to be recalculated using a different logic or different dependencies after the node has been initially created.</p>
<p><code>Note:</code> <strong>The return value type cannot be changed</strong></p>
<p>Below is an example that demonstrates the reset functionality:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TestReset, ReactionTest) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(std::string&#123;<span class="string">&quot;2&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(<span class="built_in">a</span>()); &#125;);</span><br><span class="line">    <span class="keyword">auto</span> ret = ds.<span class="built_in">set</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">b</span>() + <span class="string">&quot;set&quot;</span>; &#125;);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ret, reaction::ReactionError::NoErr);</span><br><span class="line"></span><br><span class="line">    ret = ds.<span class="built_in">set</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ret, reaction::ReactionError::ReturnTypeErr);</span><br><span class="line"></span><br><span class="line">    ret = ds.<span class="built_in">set</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">ds</span>(); &#125;);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ret, reaction::ReactionError::CycleDepErr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-Trigger-Mode"><a href="#8-Trigger-Mode" class="headerlink" title="8. Trigger Mode"></a>8. Trigger Mode</h4><p>The <code>reaction</code> framework supports various triggering mode to control when reactive computations are re-evaluated. This example demonstrates three mode:</p>
<ol>
<li><strong>Value Change Trigger:</strong> The reactive computation is triggered only when the underlying value actually changes.</li>
<li><strong>Threshold Trigger:</strong> The reactive computation is triggered when the value crosses a specified threshold.</li>
<li><strong>Always Trigger:</strong> (Not explicitly shown in this example) Always triggers regardless of whether the value has changed.</li>
</ol>
<p>The trigger Mode can be specified by the type parameter</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> reaction;</span><br><span class="line"><span class="keyword">auto</span> stockPrice = <span class="built_in">var</span>(<span class="number">100.0</span>);</span><br><span class="line"><span class="keyword">auto</span> profit = <span class="built_in">expr</span>&lt;ChangedTrigger&gt;(<span class="built_in">stockPrice</span>() - <span class="number">100.0</span>);</span><br><span class="line"><span class="keyword">auto</span> assignAction = <span class="built_in">action</span>([=]() &#123;  <span class="comment">// defalut AlwaysTrigger</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Checky assign, price = &quot;</span> &lt;&lt; <span class="built_in">stockPrice</span>() &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">auto</span> sellAction = <span class="built_in">action</span>&lt;ThresholdTrigger&gt;([=]() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;It&#x27;s time to sell, profit = &quot;</span> &lt;&lt; <span class="built_in">profit</span>() &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">sellAction.<span class="built_in">setThreshold</span>([=]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">profit</span>() &gt; <span class="number">5.0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">*stockPrice = <span class="number">100.0</span>; <span class="comment">// assignAction trigger</span></span><br><span class="line">*stockPrice = <span class="number">101.0</span>; <span class="comment">// assignAction, profit trigger</span></span><br><span class="line">*stockPrice = <span class="number">106.0</span>; <span class="comment">// all trigger</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>You can even define a trigger mode yourself in your code, just include the <strong>checkTrigger</strong> method:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTrigger</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTrigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">expr</span>&lt;MyTrigger&gt;(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="9-Invalid-Strategies"><a href="#9-Invalid-Strategies" class="headerlink" title="9. Invalid Strategies"></a>9. Invalid Strategies</h4><p>In the <code>reaction</code> framework, all data sources <strong>obtained by users are actually in the form of weak references</strong>, and their actual memory is managed <strong>in the observer map</strong>.<br>Users can manually call the <strong>close</strong> method, so that all dependent data sources will also be closed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> dsA = reaction::<span class="built_in">calc</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line"><span class="keyword">auto</span> dsB = reaction::<span class="built_in">calc</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">dsA</span>() + <span class="built_in">b</span>(); &#125;);</span><br><span class="line">dsA.<span class="built_in">close</span>(); <span class="comment">//dsB will automatically close, cause dsB dependents dsA.</span></span><br><span class="line"><span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dsA));</span><br><span class="line"><span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dsB));</span><br></pre></td></tr></table></figure>

<p>However, for scenarios where the lifecycle of a weak reference acquired by user ends, the <code>reaction</code> framework makes several strategy for different scenarios.</p>
<ul>
<li><p><strong>DirectCloseStrategy:</strong><br>The node is immediately closed (made invalid) when any of its dependencies become invalid.</p>
</li>
<li><p><strong>KeepCalcStrategy:</strong><br>The node continues to recalculate, its dependencies work normally.</p>
</li>
<li><p><strong>LastValStrategy:</strong><br>The node retains the last valid, its dependencies use the value to calculate.</p>
</li>
</ul>
<p>Below is a concise example that illustrates all three strategies:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;); <span class="comment">// default is DirectCloseStrategy</span></span><br><span class="line">        b.<span class="built_in">set</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">temp</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp lifecycle ends, b will end too.</span></span><br><span class="line">    <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b));</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">calc</span>&lt;AlwaysTrigger, KeepCalcStrategy&gt;([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;); <span class="comment">// default is DirectFailureStrategy</span></span><br><span class="line">        b.<span class="built_in">set</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">temp</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp lifecycle ends, b not be influenced.</span></span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b));</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">calc</span>&lt;AlwaysTrigger, LastValStrategy&gt;([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;); <span class="comment">// default is DirectFailureStrategy</span></span><br><span class="line">        b.<span class="built_in">set</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">temp</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp lifecycle ends, b use its last val to calculate.</span></span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b));</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Likewise, you can define a strategy yourself in your code, just include the <strong>handleInvalid</strong> method:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStrategy</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleInvalid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">expr</span>&lt;AlwaysTrigger, MyStrategy&gt;(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-总结与展望"><a href="#5-总结与展望" class="headerlink" title="5. 总结与展望"></a>5. 总结与展望</h2><p>响应式编程正加速向全栈渗透，而 C++ 在此领域尚属“荒原”。Reaction 框架希望借助 C++20 的强大能力，为 C++ 开发者提供一种全新的响应式思维模型，特别是在嵌入式界面、工业软件与复杂状态管理等高性能场景中，具备独特的优势。</p>
<p><strong>接下来的章节，我们将从零开始实现 Reaction 框架，逐步剖析其设计细节与核心实现逻辑。</strong></p>
<p>欢迎关注后续内容，一起走进响应式 C++ 的世界！</p>
<hr>
<p><em>如果你对本项目感兴趣，欢迎留言交流，或访问 GitHub 获取源码与进展！</em><br><a target="_blank" rel="noopener" href="https://github.com/lumia431/reaction">https://github.com/lumia431/reaction</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/12/Reaction%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" data-id="cm9e9088i0000iikyc9pu2b4s" data-title="从零实现响应式框架——基本概念和设计思路" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Reaction/">Reaction</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" rel="tag">\[Reactive-programming, C++, Modern-Cpp, TMP]</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/Modern-Cpp/" style="font-size: 20px;">Modern-Cpp</a> <a href="/tags/Reactive-programming/" style="font-size: 20px;">Reactive-programming</a> <a href="/tags/TMP/" style="font-size: 20px;">TMP</a> <a href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" style="font-size: 10px;">\[Reactive-programming, C++, Modern-Cpp, TMP]</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/05/09/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84private%E6%88%90%E5%91%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/">第五章：编译期反射初探！</a>
          </li>
        
          <li>
            <a href="/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/">第三章：实现数据源的生命周期管理</a>
          </li>
        
          <li>
            <a href="/2025/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">第四章：让数据源作为成员变量</a>
          </li>
        
          <li>
            <a href="/2025/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B5%B7%E6%9D%A5%EF%BC%81%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/">第二章：让数据流起来！依赖节点管理的实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Lummy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>