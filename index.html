<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Lummy的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lummy的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Lummy的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lummy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Lummy的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lummy的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-第八章：节点关系图的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/27/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2025-05-27T08:24:17.383Z" itemprop="datePublished">2025-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/27/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/">第八章：节点关系图的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第八章：节点关系图的实现"><a href="#第八章：节点关系图的实现" class="headerlink" title="第八章：节点关系图的实现"></a>第八章：节点关系图的实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(TestSelfDependency, ReactionTest) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> c = reaction::<span class="built_in">var</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dsA = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa) &#123; <span class="keyword">return</span> aa; &#125;, a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dsA.<span class="built_in">reset</span>([](<span class="type">int</span> aa, <span class="type">int</span> dsAValue) &#123; <span class="keyword">return</span> aa + dsAValue; &#125;, a, dsA),</span><br><span class="line">        reaction::ReactionError::CycleDepErr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(TestCycleDependency, ReactionTest) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> c = reaction::<span class="built_in">var</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dsA = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> bb) &#123; <span class="keyword">return</span> bb; &#125;, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dsB = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> cc) &#123; <span class="keyword">return</span> cc; &#125;, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dsC = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa) &#123; <span class="keyword">return</span> aa; &#125;, a);</span><br><span class="line"></span><br><span class="line">    dsA.<span class="built_in">reset</span>([](<span class="type">int</span> bb, <span class="type">int</span> dsBValue) &#123; <span class="keyword">return</span> bb + dsBValue; &#125;, b, dsB);</span><br><span class="line"></span><br><span class="line">    dsB.<span class="built_in">reset</span>([](<span class="type">int</span> cc, <span class="type">int</span> dsCValue) &#123; <span class="keyword">return</span> cc * dsCValue; &#125;, c, dsC);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dsC.<span class="built_in">reset</span>([](<span class="type">int</span> aa, <span class="type">int</span> dsAValue) &#123; <span class="keyword">return</span> aa - dsAValue; &#125;, a, dsA),</span><br><span class="line">        reaction::ReactionError::CycleDepErr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test for repeat dependencies and the number of trigger counts</span></span><br><span class="line"><span class="built_in">TEST</span>(TestRepeatDependency, ReactionTest) &#123;</span><br><span class="line">    <span class="comment">// ds → A, ds → a, A → a</span></span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>).<span class="built_in">setName</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>).<span class="built_in">setName</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> triggerCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> dsA = reaction::<span class="built_in">calc</span>([&amp;]() &#123;</span><br><span class="line">                               ++triggerCount;</span><br><span class="line">                               <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">b</span>(); &#125;).<span class="built_in">setName</span>(<span class="string">&quot;dsA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dsB = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">dsA</span>(); &#125;).<span class="built_in">setName</span>(<span class="string">&quot;dsB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    triggerCount = <span class="number">0</span>;</span><br><span class="line">    *a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(triggerCount, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dsB.<span class="built_in">get</span>(), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(TestRepeatDependency2, ReactionTest) &#123;</span><br><span class="line">    <span class="comment">// ds → A, ds → B, ds → C, A → a, B → a</span></span><br><span class="line">    <span class="type">int</span> triggerCountA = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> triggerCountB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>).<span class="built_in">setName</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> A = reaction::<span class="built_in">calc</span>([&amp;]() &#123; ++triggerCountA; <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="number">1</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> B = reaction::<span class="built_in">calc</span>([&amp;]() &#123; ++triggerCountB; <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="number">2</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">A</span>() + <span class="built_in">B</span>() + <span class="built_in">C</span>(); &#125;).<span class="built_in">setName</span>(<span class="string">&quot;ds&quot;</span>);</span><br><span class="line"></span><br><span class="line">    triggerCountA = <span class="number">0</span>;</span><br><span class="line">    triggerCountB = <span class="number">0</span>;</span><br><span class="line">    *a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(triggerCountA, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(triggerCountB, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(TestRepeatDependency3, ReactionTest) &#123;</span><br><span class="line">    <span class="comment">// ds → A, ds → B, A → A1, A1 → A2, A2 → a, B → B1, B1 → a</span></span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>).<span class="built_in">setName</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">1</span>).<span class="built_in">setName</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> triggerCountA = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> triggerCountB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> A2 = reaction::<span class="built_in">calc</span>([&amp;]() &#123; ++triggerCountA; <span class="keyword">return</span> <span class="built_in">a</span>() * <span class="number">2</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;A2&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> A1 = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">A2</span>() + <span class="number">1</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;A1&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> A = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">A1</span>() - <span class="number">1</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> B1 = reaction::<span class="built_in">calc</span>([&amp;]() &#123; ++triggerCountB; <span class="keyword">return</span> <span class="built_in">a</span>() - <span class="number">1</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;B1&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> B = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">B1</span>() + <span class="number">1</span>; &#125;).<span class="built_in">setName</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">A</span>() + <span class="built_in">B</span>(); &#125;).<span class="built_in">setName</span>(<span class="string">&quot;ds&quot;</span>);</span><br><span class="line">    triggerCountA = <span class="number">0</span>;</span><br><span class="line">    triggerCountB = <span class="number">0</span>;</span><br><span class="line">    *a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(triggerCountA, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(triggerCountB, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    A<span class="number">1.</span><span class="built_in">reset</span>([](<span class="keyword">auto</span> bb)&#123;<span class="keyword">return</span> bb;&#125;, b);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-系统架构图"><a href="#1-系统架构图" class="headerlink" title="1. 系统架构图"></a>1. 系统架构图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%% 系统整体架构图</span><br><span class="line">graph TD</span><br><span class="line">    A[ObserverNode] --&gt;|注册| B(ObserverGraph)</span><br><span class="line">    A --&gt;|绑定字段| C(FieldGraph)</span><br><span class="line">    B --&gt;|管理| D[节点关系网络]</span><br><span class="line">    C --&gt;|存储| E[字段-节点映射表]</span><br><span class="line"></span><br><span class="line">    style A fill:#f9f,stroke:#333</span><br><span class="line">    style B fill:#bbf,stroke:#333</span><br><span class="line">    style C fill:#bfb,stroke:#333</span><br></pre></td></tr></table></figure>

<h2 id="2-核心数据结构图解"><a href="#2-核心数据结构图解" class="headerlink" title="2. 核心数据结构图解"></a>2. 核心数据结构图解</h2><h3 id="2-1-节点关系存储结构"><a href="#2-1-节点关系存储结构" class="headerlink" title="2.1 节点关系存储结构"></a>2.1 节点关系存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%% 数据结构关系图</span><br><span class="line">classDiagram</span><br><span class="line">    class ObserverGraph&#123;</span><br><span class="line">        +m_observerList: Map&lt;NodePtr, ObserverSet&gt;</span><br><span class="line">        +m_dependentList: Map&lt;NodePtr, DependentSet&gt;</span><br><span class="line">        +m_repeatList: Map&lt;NodePtr, RepeatCountMap&gt;</span><br><span class="line">        +m_nameList: Map&lt;NodePtr, String&gt;</span><br><span class="line">        +addObserver()</span><br><span class="line">        +checkCycle()</span><br><span class="line">        +closeNode()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ObserverNode&#123;</span><br><span class="line">        -m_observers: NodeSet</span><br><span class="line">        -m_repeats: NodeMap</span><br><span class="line">        +valueChanged()</span><br><span class="line">        +notify()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObserverGraph &quot;1&quot; --&gt; &quot;*&quot; ObserverNode</span><br></pre></td></tr></table></figure>

<h3 id="2-2-实际内存结构示意图"><a href="#2-2-实际内存结构示意图" class="headerlink" title="2.2 实际内存结构示意图"></a>2.2 实际内存结构示意图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|   ObserverGraph     |</span><br><span class="line">+---------------------+</span><br><span class="line">|  m_observerList     |--&gt; [NodeA: &#123;NodeB, NodeC&#125;]</span><br><span class="line">|                     |    [NodeB: &#123;NodeD&#125;]</span><br><span class="line">|  m_dependentList    |--&gt; [NodeB: &#123;NodeA&#125;]</span><br><span class="line">|                     |    [NodeC: &#123;NodeA&#125;]</span><br><span class="line">|  m_repeatList       |--&gt; [NodeD: &#123;NodeA:2&#125;]</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<h2 id="3-关键流程详解"><a href="#3-关键流程详解" class="headerlink" title="3. 关键流程详解"></a>3. 关键流程详解</h2><h3 id="3-1-添加观察者流程"><a href="#3-1-添加观察者流程" class="headerlink" title="3.1 添加观察者流程"></a>3.1 添加观察者流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%% 添加观察者序列图</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant User</span><br><span class="line">    participant SourceNode</span><br><span class="line">    participant ObserverGraph</span><br><span class="line">    participant TargetNode</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;SourceNode: updateObservers(TargetNode)</span><br><span class="line">    SourceNode-&gt;&gt;ObserverGraph: addObserver(Source, Target)</span><br><span class="line">    ObserverGraph-&gt;&gt;ObserverGraph: 检查自观察</span><br><span class="line">    alt 自观察</span><br><span class="line">        ObserverGraph--&gt;&gt;SourceNode: 返回错误</span><br><span class="line">    else</span><br><span class="line">        ObserverGraph-&gt;&gt;ObserverGraph: DFS检查循环依赖</span><br><span class="line">        alt 存在循环</span><br><span class="line">            ObserverGraph--&gt;&gt;SourceNode: 返回错误</span><br><span class="line">        else</span><br><span class="line">            ObserverGraph-&gt;&gt;ObserverGraph: 检查重复依赖路径</span><br><span class="line">            ObserverGraph-&gt;&gt;TargetNode: 添加到m_observers</span><br><span class="line">            ObserverGraph-&gt;&gt;SourceNode: 添加到m_dependentList</span><br><span class="line">            ObserverGraph--&gt;&gt;SourceNode: 返回成功</span><br><span class="line">        end</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h3 id="3-2-节点通知流程"><a href="#3-2-节点通知流程" class="headerlink" title="3.2 节点通知流程"></a>3.2 节点通知流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%% 节点通知流程图</span><br><span class="line">graph LR</span><br><span class="line">    A[节点值变更] --&gt; B[调用valueChanged]</span><br><span class="line">    B --&gt; C&#123;是否有重复依赖?&#125;</span><br><span class="line">    C --&gt;|是| D[加入重复列表]</span><br><span class="line">    C --&gt;|否| E[立即通知]</span><br><span class="line">    D --&gt; F[最后批量通知重复节点]</span><br><span class="line">    E --&gt; G[遍历观察者链]</span><br><span class="line">    G --&gt; H[触发下游更新]</span><br></pre></td></tr></table></figure>

<h2 id="4-典型场景图示"><a href="#4-典型场景图示" class="headerlink" title="4. 典型场景图示"></a>4. 典型场景图示</h2><h3 id="4-1-正常观察链"><a href="#4-1-正常观察链" class="headerlink" title="4.1 正常观察链"></a>4.1 正常观察链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%% 正常观察关系图</span><br><span class="line">graph LR</span><br><span class="line">    A[数据节点] --&gt; B[视图组件1]</span><br><span class="line">    A --&gt; C[视图组件2]</span><br><span class="line">    B --&gt; D[聚合视图]</span><br><span class="line">    C --&gt; D</span><br></pre></td></tr></table></figure>

<h3 id="4-2-循环依赖检测"><a href="#4-2-循环依赖检测" class="headerlink" title="4.2 循环依赖检测"></a>4.2 循环依赖检测</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% 循环依赖示例图</span><br><span class="line">graph TD</span><br><span class="line">    A --&gt; B</span><br><span class="line">    B --&gt; C</span><br><span class="line">    C --&gt; A</span><br><span class="line">    style A stroke:#f00,stroke-width:2px</span><br><span class="line">    style B stroke:#f00,stroke-width:2px</span><br><span class="line">    style C stroke:#f00,stroke-width:2px</span><br></pre></td></tr></table></figure>

<h3 id="4-3-重复依赖处理"><a href="#4-3-重复依赖处理" class="headerlink" title="4.3 重复依赖处理"></a>4.3 重复依赖处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%% 重复依赖示例图</span><br><span class="line">graph LR</span><br><span class="line">    A --&gt; B</span><br><span class="line">    A --&gt; C</span><br><span class="line">    B --&gt; D</span><br><span class="line">    C --&gt; D</span><br><span class="line"></span><br><span class="line">    subgraph 重复依赖</span><br><span class="line">    D</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h2 id="5-状态转换图"><a href="#5-状态转换图" class="headerlink" title="5. 状态转换图"></a>5. 状态转换图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%% 节点生命周期状态图</span><br><span class="line">stateDiagram-v2</span><br><span class="line">    [*] --&gt; Created</span><br><span class="line">    Created --&gt; Active: addNode</span><br><span class="line">    Active --&gt; Observing: addObserver</span><br><span class="line">    Observing --&gt; Closed: closeNode</span><br><span class="line">    Closed --&gt; [*]</span><br><span class="line"></span><br><span class="line">    state Observing &#123;</span><br><span class="line">        [*] --&gt; Normal</span><br><span class="line">        Normal --&gt; HasRepeats: 检测到重复依赖</span><br><span class="line">        HasRepeats --&gt; Normal: 重复计数清零</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-性能优化要点"><a href="#6-性能优化要点" class="headerlink" title="6. 性能优化要点"></a>6. 性能优化要点</h2><ol>
<li><p><strong>依赖检查优化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DFS优化策略]</span><br><span class="line">┌───────────────┐    ┌───────────────┐</span><br><span class="line">│ 临时添加边    │───&gt;│ 执行DFS检查   │</span><br><span class="line">└───────────────┘    └───────────────┘</span><br><span class="line">         ▲                  │</span><br><span class="line">         └──────────────────┘</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>批量通知机制</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">普通通知路径: 节点 → 直接观察者</span><br><span class="line">┌───────────────────────────────────────┐</span><br><span class="line">│ 重复依赖处理路径:                      │</span><br><span class="line">│ 1. 收集所有重复节点                   │</span><br><span class="line">│ 2. 主通知流程完成后批量触发           │</span><br><span class="line">└───────────────────────────────────────┘</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-异常处理图示"><a href="#7-异常处理图示" class="headerlink" title="7. 异常处理图示"></a>7. 异常处理图示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%% 错误处理流程图</span><br><span class="line">graph TD</span><br><span class="line">    A[操作请求] --&gt; B&#123;是否有效节点?&#125;</span><br><span class="line">    B --&gt;|否| C[返回无效节点错误]</span><br><span class="line">    B --&gt;|是| D&#123;是否自观察?&#125;</span><br><span class="line">    D --&gt;|是| E[返回自观察错误]</span><br><span class="line">    D --&gt;|否| F&#123;是否循环依赖?&#125;</span><br><span class="line">    F --&gt;|是| G[返回循环依赖错误]</span><br><span class="line">    F --&gt;|否| H[执行操作]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/27/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cmb698cyp000044kya0u67uv1" data-title="第八章：节点关系图的实现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第七章：表达式模板的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/13/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2025-05-13T06:40:30.277Z" itemprop="datePublished">2025-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/13/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/">第七章：表达式模板的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第七章：表达式模板的使用"><a href="#第七章：表达式模板的使用" class="headerlink" title="第七章：表达式模板的使用"></a>第七章：表达式模板的使用</h1><p>在实现表达式模板之前，我们先做一些准备工作。</p>
<p>首先实现action之间的依赖，一个action可以触发其他的action：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestAction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> at = reaction::<span class="built_in">action</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb)</span><br><span class="line">                               &#123; std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; aa &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; bb &lt;&lt; <span class="string">&#x27;\t&#x27;</span>; &#125;, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> trigger = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> att = reaction::<span class="built_in">action</span>([&amp;]([[maybe_unused]] <span class="keyword">auto</span> atat)</span><br><span class="line">                                &#123; trigger = <span class="literal">true</span>; std::cout &lt;&lt; <span class="string">&quot;at trigger &quot;</span> &lt;&lt; std::endl; &#125;, at);</span><br><span class="line"></span><br><span class="line">    trigger = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(trigger);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要对void类型做一个包装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VoidWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>&lt;VoidWrapper&gt; : <span class="keyword">public</span> ObserverNode</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">VoidWrapper <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> VoidWrapper&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后实现数据源的重置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestReset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line"></span><br><span class="line">    dds.<span class="built_in">reset</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> aa + dsds; &#125;, a, ds);</span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里涉及到一个问题，之前我们是用一个tuple来保存形参包的，现在这个形参包的类型和个数会被重置，那么如何保存一个可变的形参包呢？<br>答案是std::function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> : <span class="keyword">public</span> Resource&lt;ReturnType&lt;Fun, Args...&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ValueType = ReturnType&lt;Fun, Args...&gt;;</span><br><span class="line">    <span class="keyword">using</span> ExprType = CalcExpr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... A&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSource</span><span class="params">(F &amp;&amp;f, A &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::convertible_to&lt;ReturnType&lt;std::<span class="type">decay_t</span>&lt;F&gt;, std::<span class="type">decay_t</span>&lt;A&gt;...&gt;, ValueType&gt;)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">updateObservers</span>(std::forward&lt;A&gt;(args)...);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">setFunctor</span>(<span class="built_in">createFun</span>(std::forward&lt;F&gt;(f), std::forward&lt;A&gt;(args)...));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">evaluate</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... A&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">createFun</span><span class="params">(F &amp;&amp;f, A &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [f = std::forward&lt;F&gt;(f), ...args = args.<span class="built_in">getPtr</span>()]() <span class="comment">// C++20</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">constexpr</span> (VoidType&lt;ValueType&gt;)</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">invoke</span>(f, args-&gt;<span class="built_in">get</span>()...);</span><br><span class="line">                <span class="keyword">return</span> VoidWrapper&#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f, args-&gt;<span class="built_in">get</span>()...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">valueChanged</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">evaluate</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">evaluate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(VoidType&lt;ValueType&gt;)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::<span class="built_in">invoke</span>(m_fun);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">updateValue</span>(std::<span class="built_in">invoke</span>(m_fun));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFunctor</span><span class="params">(<span class="type">const</span> std::function&lt;ValueType()&gt; &amp;fun)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_fun = fun;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::function&lt;ValueType()&gt; m_fun;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后实现()语法糖的封装，实现自动注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestParentheses) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(a.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">b</span>(); &#125;);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(<span class="built_in">a</span>()) + std::<span class="built_in">to_string</span>(<span class="built_in">ds</span>()); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;14.140000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">5.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;25.140000&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(F &amp;&amp;f)</span> </span>&#123;</span><br><span class="line">    g_reg_fun = [<span class="keyword">this</span>](NodePtr node) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">addObCb</span>(node);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">setSource</span>(std::forward&lt;F&gt;(f));</span><br><span class="line">    g_reg_fun = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后是表达式模板的封装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestExpr) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> c = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">b</span>(); &#125;);</span><br><span class="line">    <span class="keyword">auto</span> expr_ds = reaction::<span class="built_in">expr</span>(c + a / b - ds * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(expr_ds.<span class="built_in">get</span>(), <span class="number">-3.86</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="一、表达式模板是什么？"><a href="#一、表达式模板是什么？" class="headerlink" title="一、表达式模板是什么？"></a>一、表达式模板是什么？</h2><p><strong>表达式模板（Expression Template）</strong> 是一种 <strong>延迟求值（Lazy Evaluation）</strong> 技术，通过 C++ 模板和运算符重载，在编译期构建表达式的语法树，然后在需要时一次性计算整个表达式，<strong>避免中间结果的拷贝或临时对象的生成</strong>。</p>
<p>最早由 Todd Veldhuizen 在处理 C++ 数组库（如 Blitz++）时提出，用于提高性能。</p>
<hr>
<h2 id="二、它解决了什么问题？"><a href="#二、它解决了什么问题？" class="headerlink" title="二、它解决了什么问题？"></a>二、它解决了什么问题？</h2><p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector a, b, c, d;</span><br><span class="line">a = b + c + d;</span><br></pre></td></tr></table></figure>

<p>传统实现中，<code>b + c</code> 产生一个临时对象 <code>temp1</code>，然后 <code>temp1 + d</code> 再产生另一个临时对象 <code>temp2</code>，最终赋值给 <code>a</code>，造成了多次内存分配和复制。</p>
<p>而使用表达式模板，<code>b + c + d</code> 不会立即执行，而是生成一个表达式类型 <code>AddExpr&lt;AddExpr&lt;b, c&gt;, d&gt;</code>，等 <code>a = ...</code> 的时候再统一执行，从而避免了中间变量，提高效率。</p>
<hr>
<h2 id="三、基本原理"><a href="#三、基本原理" class="headerlink" title="三、基本原理"></a>三、基本原理</h2><p>核心思想是：</p>
<ul>
<li><strong>重载运算符返回表达式类型</strong>（如 <code>+</code> 返回 <code>BinaryOpExpr</code>）</li>
<li><strong>延迟求值</strong>，即表达式本身只是“记录”结构</li>
<li><strong>调用时再执行</strong>（如 <code>operator()</code> 或强制类型转换）</li>
</ul>
<h3 id="示例结构："><a href="#示例结构：" class="headerlink" title="示例结构："></a>示例结构：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子值包装器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> ValueType = T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Value</span>(T val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式类型：二元操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Op, <span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryOpExpr</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> ValueType = std::<span class="type">common_type_t</span>&lt;<span class="keyword">typename</span> L::ValueType, <span class="keyword">typename</span> R::ValueType&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BinaryOpExpr</span>(L l, R r, Op o = Op&#123;&#125;) : <span class="built_in">left</span>(l), <span class="built_in">right</span>(r), <span class="built_in">op</span>(o) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ValueType <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op</span>(<span class="built_in">left</span>(), <span class="built_in">right</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    L left;</span><br><span class="line">    R right;</span><br><span class="line">    Op op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>+(L l, R r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BinaryOpExpr</span>&lt;AddOp, L, R&gt;(l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、表达式模板的优点"><a href="#四、表达式模板的优点" class="headerlink" title="四、表达式模板的优点"></a>四、表达式模板的优点</h2><p>✅ <strong>性能优化（零拷贝）</strong><br>✅ <strong>编译期构建计算图</strong><br>✅ <strong>高度可组合</strong><br>✅ <strong>适用于数学类库（矩阵、向量）、响应式编程、DSL 构建等</strong></p>
<hr>
<h2 id="五、表达式模板的应用场景"><a href="#五、表达式模板的应用场景" class="headerlink" title="五、表达式模板的应用场景"></a>五、表达式模板的应用场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>数值计算</td>
<td>Blitz++、Eigen、xtensor</td>
</tr>
<tr>
<td>图形编程</td>
<td>OpenGL DSL、Shader 表达式</td>
</tr>
<tr>
<td>信号处理</td>
<td>响应式框架：RxCpp、C++ reactive dataflow</td>
</tr>
<tr>
<td>自定义 DSL</td>
<td>嵌入式编程、财务表达式等</td>
</tr>
<tr>
<td>表达式构建器</td>
<td>SQL 查询构建、规则引擎</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://godbolt.org/z/z4Ye5PqsK">https://godbolt.org/z/z4Ye5PqsK</a></p>
<hr>
<p>在 C++ 中，空类（没有任何成员变量或非静态成员函数的类）默认情况下会占用 <strong>1 字节</strong>的内存空间（用于确保不同对象的地址唯一）。但可以通过以下方法去掉或优化其大小：</p>
<h3 id="使用-no-unique-address-（C-20-引入）"><a href="#使用-no-unique-address-（C-20-引入）" class="headerlink" title="使用 [[no_unique_address]]（C++20 引入）"></a><strong>使用 <code>[[no_unique_address]]</code>（C++20 引入）</strong></h3><ul>
<li><strong>作用</strong>：允许空成员变量不占用额外空间（如果它是空的）。</li>
<li><strong>适用场景</strong>：空类作为成员变量时（如空基类、无状态的策略类）。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;; <span class="comment">// 空类，默认占 1 字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Optimized</span> &#123;</span><br><span class="line">    [[no_unique_address]] Empty e; <span class="comment">// 可能不占用空间（取决于编译器优化）</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Optimized) == <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 可能成立</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：是否真正优化取决于编译器实现和成员布局规则（如 MSVC 可能仍需对齐）。</li>
</ul>
</li>
</ul>
<hr>
<p><code>std::common_type_t</code> 是 C++11 引入的一个类型萃取工具，用于从多个类型中<strong>推导出它们的公共类型</strong>，即它们能隐式转换到的最“宽泛”的一个类型。</p>
<h2 id="🧠-基本概念"><a href="#🧠-基本概念" class="headerlink" title="🧠 基本概念"></a>🧠 基本概念</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">common_type_t</span> = <span class="keyword">typename</span> std::common_type&lt;T...&gt;::type;</span><br></pre></td></tr></table></figure>

<ul>
<li>它是 <code>std::common_type&lt;T...&gt;</code> 的类型别名（简写形式）。</li>
<li>用于推导多个类型的“<strong>共同类型</strong>”（比如用于运算、返回值、参数统一等场景）。</li>
</ul>
<hr>
<h2 id="✅-示例-1：两个基本类型"><a href="#✅-示例-1：两个基本类型" class="headerlink" title="✅ 示例 1：两个基本类型"></a>✅ 示例 1：两个基本类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">common_type_t</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt; x; <span class="comment">// 推导为 double</span></span><br></pre></td></tr></table></figure>

<p>解释：因为 <code>int</code> 可以隐式转换成 <code>double</code>，但 <code>double</code> 不能无损转为 <code>int</code>，所以 <code>double</code> 是更“通用”的类型。</p>
<hr>
<h2 id="✅-示例-2：三个类型"><a href="#✅-示例-2：三个类型" class="headerlink" title="✅ 示例 2：三个类型"></a>✅ 示例 2：三个类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">common_type_t</span>&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt; x; <span class="comment">// 结果是 double</span></span><br></pre></td></tr></table></figure>

<p>解释：<code>int</code>、<code>float</code> 都能隐式转换为 <code>double</code>，所以 <code>double</code> 是最合适的公共类型。</p>
<hr>
<h2 id="✅-示例-3：自定义类型"><a href="#✅-示例-3：自定义类型" class="headerlink" title="✅ 示例 3：自定义类型"></a>✅ 示例 3：自定义类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;&#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="type">common_type_t</span>&lt;A, B&gt; obj; <span class="comment">// 推导为 A</span></span><br></pre></td></tr></table></figure>

<p>解释：<code>B</code> 可以转为 <code>A</code>，所以 <code>A</code> 是公共基类型。</p>
<hr>
<h2 id="✅-示例-4：结合表达式模板"><a href="#✅-示例-4：结合表达式模板" class="headerlink" title="✅ 示例 4：结合表达式模板"></a>✅ 示例 4：结合表达式模板</h2><p>在表达式模板中，我们通常这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Op, <span class="keyword">typename</span> L, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryOpExpr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ValueType = std::<span class="type">common_type_t</span>&lt;<span class="keyword">typename</span> L::ValueType, <span class="keyword">typename</span> R::ValueType&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**目的：**如果 <code>L::ValueType</code> 是 <code>int</code>，<code>R::ValueType</code> 是 <code>double</code>，我们就自动推导出 <code>ValueType = double</code>，避免类型不匹配。</p>
<hr>
<h2 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h2><ol>
<li><p><code>std::common_type_t</code> 会考虑 <strong>三元运算符规则</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">common_type_t</span>&lt;<span class="type">int</span>, <span class="type">long</span>, <span class="type">float</span>&gt; <span class="comment">// 是 float（因为 int ? long : float 是 float）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果两个类型没有公共类型（比如你自定义的类型没有相互转换），则会编译失败。</p>
</li>
</ol>
<hr>
<h2 id="🛠️-实际用途"><a href="#🛠️-实际用途" class="headerlink" title="🛠️ 实际用途"></a>🛠️ 实际用途</h2><ul>
<li>推导表达式模板的值类型（<code>+</code>、<code>-</code>、<code>*</code> 等）</li>
<li>函数模板返回值统一</li>
<li>SFINAE 判断（如果不存在共同类型就不启用函数）</li>
<li>类型安全统一转换</li>
</ul>
<hr>
<h2 id="🧾-总结表"><a href="#🧾-总结表" class="headerlink" title="🧾 总结表"></a>🧾 总结表</h2><table>
<thead>
<tr>
<th>示例</th>
<th><code>std::common_type_t&lt;T1, T2&gt;</code> 的结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>int, double</code></td>
<td><code>double</code></td>
</tr>
<tr>
<td><code>float, double</code></td>
<td><code>double</code></td>
</tr>
<tr>
<td><code>int, unsigned int</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>A, B</code>（B继承自A）</td>
<td><code>A</code></td>
</tr>
<tr>
<td><code>std::string, const char*</code></td>
<td><code>std::string</code>（因为 const char* 可转为 string）</td>
</tr>
</tbody></table>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BasedOnStyle: LLVM</span><br><span class="line">IndentWidth: <span class="number">4</span></span><br><span class="line">ColumnLimit: <span class="number">0</span></span><br><span class="line">BinPackArguments: <span class="literal">true</span></span><br><span class="line">AccessModifierOffset: <span class="number">-4</span></span><br><span class="line">AlignAfterOpenBracket: DontAlign</span><br><span class="line">AllowShortIfStatementsOnASingleLine: <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/13/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="cmaphr4vw00002kky9hor7lj1" data-title="第七章：表达式模板的使用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第六章：编译期反射private成员" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/09/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84private%E6%88%90%E5%91%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-09T09:02:28.358Z" itemprop="datePublished">2025-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/09/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84private%E6%88%90%E5%91%98/">第六章：编译期反射 private 成员</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="第六章：编译期反射-private-成员"><a href="#第六章：编译期反射-private-成员" class="headerlink" title="第六章：编译期反射 private 成员"></a>第六章：编译期反射 private 成员</h1><blockquote>
<p>上一章我们已经介绍了对于聚合类型的编译期反射，本章我们介绍对于非聚合类型如何反射。</p>
</blockquote>
<p>首先看一下知乎的 <strong>YKIKO</strong> 在有状态黑魔法中提到的例子：<br>👉 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/646752343">https://zhuanlan.zhihu.com/p/646752343</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money = <span class="number">999&#x27;999&#x27;999&#x27;999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Thief</span>&lt;&amp;Bank::money&gt;;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&amp;Bank::money</code> 是一个<strong>成员变量指针</strong>，不同于普通的指针，它并不依赖于某个对象，而表示该成员在类中的偏移量，是一个<strong>编译期常量</strong>。</p>
<p>在 C++ 中，<strong>成员指针（Pointer-to-Member）</strong> 和 <strong>普通指针（Pointer-to-Object&#x2F;Pointer-to-Function）</strong> 是两种不同的概念，它们的类型、语法和用途都有显著区别。下面详细对比它们的差异：</p>
<hr>
<h2 id="1-类型定义"><a href="#1-类型定义" class="headerlink" title="1. 类型定义"></a><strong>1. 类型定义</strong></h2><h3 id="（1）普通指针"><a href="#（1）普通指针" class="headerlink" title="（1）普通指针"></a><strong>（1）普通指针</strong></h3><ul>
<li><strong>指向对象</strong>：<code>T*</code>（指向类型 <code>T</code> 的对象）</li>
<li><strong>指向函数</strong>：<code>R (*)(Args...)</code>（指向返回 <code>R</code>、参数为 <code>Args...</code> 的函数）</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;  <span class="comment">// 普通指针，指向 int 对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>) = &amp;foo;  <span class="comment">// 普通函数指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（2）成员指针"><a href="#（2）成员指针" class="headerlink" title="（2）成员指针"></a><strong>（2）成员指针</strong></h3><ul>
<li><strong>指向成员变量</strong>：<code>T C::*</code>（指向类 <code>C</code> 的成员变量，类型为 <code>T</code>）</li>
<li><strong>指向成员函数</strong>：<code>R (C::*)(Args...)</code>（指向类 <code>C</code> 的成员函数）</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Bank::* money_ptr = &amp;Bank::money;  <span class="comment">// 成员变量指针</span></span><br><span class="line"><span class="built_in">void</span> (Bank::* check_ptr)() <span class="type">const</span> = &amp;Bank::check;  <span class="comment">// 成员函数指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2. 使用方式"></a><strong>2. 使用方式</strong></h2><h3 id="（1）普通指针-1"><a href="#（1）普通指针-1" class="headerlink" title="（1）普通指针"></a><strong>（1）普通指针</strong></h3><ul>
<li>直接解引用访问：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">*ptr = <span class="number">20</span>;  <span class="comment">// 直接修改 x</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（2）成员指针-1"><a href="#（2）成员指针-1" class="headerlink" title="（2）成员指针"></a><strong>（2）成员指针</strong></h3><ul>
<li><strong>必须结合对象</strong> 才能访问：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bank bank;</span><br><span class="line"><span class="type">double</span> Bank::* money_ptr = &amp;Bank::money;</span><br><span class="line">bank.*money_ptr = <span class="number">100</span>;  <span class="comment">// 等价于 bank.money = 100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (Bank::* check_ptr)() <span class="type">const</span> = &amp;Bank::check;</span><br><span class="line">(bank.*check_ptr)();  <span class="comment">// 等价于 bank.check()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-存储方式"><a href="#3-存储方式" class="headerlink" title="3. 存储方式"></a><strong>3. 存储方式</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>普通指针</th>
<th>成员指针</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储地址</strong></td>
<td>直接存储对象&#x2F;函数的地址</td>
<td>存储的是 <strong>相对于类对象的偏移量</strong>（成员变量）或 <strong>函数地址+调整信息</strong>（成员函数）</td>
</tr>
<tr>
<td><strong>是否依赖对象</strong></td>
<td>可以直接解引用</td>
<td>必须绑定到对象才能使用（<code>obj.*ptr</code> 或 <code>obj-&gt;*ptr</code>）</td>
</tr>
<tr>
<td><strong><code>sizeof</code> 大小</strong></td>
<td>通常等于机器字长（如 8 字节）</td>
<td>可能比普通指针大（成员函数指针可能占用 2 个机器字）</td>
</tr>
</tbody></table>
<hr>
<h2 id="👀-显示实例化与私有访问权限"><a href="#👀-显示实例化与私有访问权限" class="headerlink" title="👀 显示实例化与私有访问权限"></a>👀 显示实例化与私有访问权限</h2><p>这里还用到了模板<strong>显示实例化时会忽略类作用域访问权限</strong>的特性。</p>
<h3 id="🔍-什么是显示实例化？"><a href="#🔍-什么是显示实例化？" class="headerlink" title="🔍 什么是显示实例化？"></a>🔍 什么是显示实例化？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;        <span class="comment">// 显式实例化类模板</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myFunc</span>&lt;<span class="type">double</span>&gt;();     <span class="comment">// 显式实例化函数模板</span></span><br></pre></td></tr></table></figure>

<p>这强制编译器在该位置生成实例代码，而不是等到首次使用。</p>
<h3 id="✅-优点"><a href="#✅-优点" class="headerlink" title="✅ 优点"></a>✅ 优点</h3><ul>
<li>减少编译时间</li>
<li>减少重复实例化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;; <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>

<p>其他文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;; <span class="comment">// 声明：避免重复生成</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚠️-无法访问-private-成员的问题"><a href="#⚠️-无法访问-private-成员的问题" class="headerlink" title="⚠️ 无法访问 private 成员的问题"></a>⚠️ 无法访问 private 成员的问题</h2><p>但是问题来了，即使我们显示实例化了Thief&lt;&amp;Bank::money&gt;，编译器也帮我们生成了这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&amp;Bank::money&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>你甚至已经想好了利用Thief的类型参数做各种操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;mp = &amp;Bank::money&gt;</span><br><span class="line"><span class="keyword">struct</span> Thief &#123;</span><br><span class="line">    <span class="type">double</span>&amp; <span class="built_in">steal</span>(Bank&amp; bank) &#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span>&amp; <span class="title">steal2</span><span class="params">(Bank&amp; bank)</span> </span>&#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是有什么用呢，你无法使用Thief中的任何成员函数，因为Thief本身是一个类模板，想使用Thief必须要指定类型参数。<br>一旦你指定了Thief&lt;&amp;Bank::money&gt;去隐式实例化一个Thief，会立马报错因为无法访问&amp;Bank::money。</p>
<p>那么我显示实例化生成的代码岂不是卵用没有？</p>
<p>这就需要结合友元函数来使用，友元函数与普通函数最大的不同就在于不要求函数定义与函数声明在同一scope中，所以我们就可以非Thief的作用域下使用它。</p>
<p>具体来说就是在全局的scope去声明该友元函数；而在Thief&lt;&amp;Bank::money&gt;的scope去定义友元函数，同时窃取它的非类型参数，这样我们就可以在全局的scope去使用它，绕过了必须隐式实例化Thief才能使用它的限制。</p>
<h2 id="🪄-解决方案：友元函数-显示实例化"><a href="#🪄-解决方案：友元函数-显示实例化" class="headerlink" title="🪄 解决方案：友元函数 + 显示实例化"></a>🪄 解决方案：友元函数 + 显示实例化</h2><p>利用<strong>友元函数</strong>的特性，可以在类模板内部定义，在外部声明，从而绕开访问权限。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money = <span class="number">999&#x27;999&#x27;999&#x27;999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span> </span>&#123; <span class="keyword">return</span> bank.*mp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(Bank&amp; bank)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Thief</span>&lt;&amp;Bank::money&gt;; <span class="comment">// #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bank bank;</span><br><span class="line">    <span class="built_in">steal</span>(bank) = <span class="number">100</span>; <span class="comment">// #3</span></span><br><span class="line">    bank.<span class="built_in">check</span>(); <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我曾经幻想利用这个机制实现一个thief的库，把显式实例化和友元函数都封装在库中，用户只需注册成员就可以直接使用库中的steal方法获取私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bank bank;</span><br><span class="line">    <span class="built_in">REGISTER</span>(Bank, money);</span><br><span class="line">    <span class="built_in">steal</span>(bank) = <span class="number">100</span>;</span><br><span class="line">    bank.<span class="built_in">check</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是显式实例化必须在全局命名空间 或 命名空间作用域，不能出现在函数内部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> mp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thief</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.*mp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">steal</span><span class="params">(T&amp;&amp; t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER(STRUCT, MEMBER) \</span></span><br><span class="line"><span class="meta">    template struct Thief<span class="string">&lt;&amp;STRUCT::MEMBER&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="type">double</span> money = <span class="number">999&#x27;999&#x27;999&#x27;999</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; money &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bank bank;</span><br><span class="line">    <span class="built_in">REGISTER</span>(Bank, money); <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">steal</span>(bank) = <span class="number">100</span>;</span><br><span class="line">    bank.<span class="built_in">check</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是因为<strong>显式实例化声明和定义</strong>（如 <code>template struct Thief&lt;&amp;Bank::money&gt;;</code>）在 C++ 标准中被<strong>限定只能出现在命名空间作用域</strong>（即：全局作用域或某个命名空间中），不能放在函数体（比如 <code>main</code>）里。这是出于以下几个原因：</p>
<hr>
<h3 id="✅-1-语言标准限制（语法层面）"><a href="#✅-1-语言标准限制（语法层面）" class="headerlink" title="✅ 1. 语言标准限制（语法层面）"></a>✅ 1. <strong>语言标准限制（语法层面）</strong></h3><p>C++ 标准（[C++20 §14.7.2]）明确指出：</p>
<blockquote>
<p><em>An explicit instantiation shall appear in a namespace scope (not inside a function or class).</em></p>
</blockquote>
<p>这是<strong>语法层面</strong>的硬性规定，编译器会直接报错，不予接受。</p>
<hr>
<h3 id="✅-2-链接模型设计：实例化必须唯一可见"><a href="#✅-2-链接模型设计：实例化必须唯一可见" class="headerlink" title="✅ 2. 链接模型设计：实例化必须唯一可见"></a>✅ 2. <strong>链接模型设计：实例化必须唯一可见</strong></h3><p>显式实例化通常意味着「我手动生成这个模板的具体版本，别再自己自动生成了」，这影响<strong>符号的生成和链接行为</strong>：</p>
<ul>
<li>如果你允许它在函数内，会在函数作用域内临时生成一个实例；</li>
<li>但别的地方可能还会再实例化一次，违反 One Definition Rule（ODR）；</li>
<li>放在全局作用域可以控制符号的唯一性，符合链接器模型。</li>
</ul>
<hr>
<h2 id="🧩-泛化实现：反射-private-成员"><a href="#🧩-泛化实现：反射-private-成员" class="headerlink" title="🧩 泛化实现：反射 private 成员"></a>🧩 泛化实现：反射 private 成员</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span>... field&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">private_visitor</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_private_ptrs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(field...);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFL_PRIVATE(STRUCT, ...) \</span></span><br><span class="line"><span class="meta">  inline constexpr auto get_private_ptrs(); \</span></span><br><span class="line"><span class="meta">  template struct private_visitor<span class="string">&lt;STRUCT, ##__VA_ARGS__&gt;</span>;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">    Field&lt;std::string&gt; m_name;</span><br><span class="line">    Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REFL_PRIVATE</span>(PersonPrivate, &amp;PersonPrivate::m_name, &amp;PersonPrivate::m_age, &amp;PersonPrivate::m_male)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧭-为了避免-ODR-冲突-——-添加类型参数"><a href="#🧭-为了避免-ODR-冲突-——-添加类型参数" class="headerlink" title="🧭 为了避免 ODR 冲突 —— 添加类型参数"></a>🧭 为了避免 ODR 冲突 —— 添加类型参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span>... field&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">private_visitor</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_private_ptrs</span><span class="params">(<span class="type">const</span> my_wrapper&lt;T&gt;&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(field...);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFL_PRIVATE(STRUCT, ...) \</span></span><br><span class="line"><span class="meta">  inline constexpr auto get_private_ptrs(const my_wrapper<span class="string">&lt;STRUCT&gt;</span> &amp;t); \</span></span><br><span class="line"><span class="meta">  template struct private_visitor<span class="string">&lt;STRUCT, ##__VA_ARGS__&gt;</span>;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧠-SFINAE-萃取成员类型"><a href="#🧠-SFINAE-萃取成员类型" class="headerlink" title="🧠 SFINAE 萃取成员类型"></a>🧠 SFINAE 萃取成员类型</h2><p>我们可以从成员指针中推导其类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C, T C::*MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>&lt;MemberPtr&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">    <span class="keyword">using</span> class_type = C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">using</span> member_value_v = <span class="keyword">typename</span> MemberPointerTraits&lt;MemberPtr&gt;::type;</span><br></pre></td></tr></table></figure>

<p>至此，我们实现了：</p>
<ul>
<li>✅ 聚合类型的反射</li>
<li>✅ 非聚合类型的反射</li>
<li>✅ 编译期萃取字段类型</li>
<li>✅ 编译期获取字段名称</li>
</ul>
<p>真正意义上的<strong>非侵入式编译期反射机制</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Field</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_wrapper</span> &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">static</span> T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span>... field&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">private_visitor</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_private_ptrs</span><span class="params">(<span class="type">const</span> my_wrapper&lt;T&gt;&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(field...);</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFL_PRIVATE(STRUCT, ...)                                         \</span></span><br><span class="line"><span class="meta">  inline constexpr auto get_private_ptrs(const my_wrapper<span class="string">&lt;STRUCT&gt;</span> &amp;t);      \</span></span><br><span class="line"><span class="meta">  template struct private_visitor<span class="string">&lt;STRUCT, ##__VA_ARGS__&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REFL_PRIVATE</span>(PersonPrivate, &amp;PersonPrivate::m_name, &amp;PersonPrivate::m_age, &amp;PersonPrivate::m_male)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyType</span> &#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">size_t</span> <span class="title">countMember</span><span class="params">(<span class="keyword">auto</span>&amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!<span class="keyword">requires</span> &#123; T&#123; Args... &#125;; &#125;)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">sizeof</span>...(Args) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">countMember</span>&lt;T&gt;(Args..., AnyType&#123;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> member_count_v = <span class="built_in">countMember</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> T&amp; <span class="title">get_global_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_wrapper&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span>&lt;Field&lt;T&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">check_field</span><span class="params">(<span class="type">const</span> Tuple&amp; tuple)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">apply</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp;... args) &#123;</span><br><span class="line">		((found = found || Is_Field&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(args)&gt;&gt;()), ...);</span><br><span class="line">		&#125;, tuple);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> ptr&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">	<span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">	<span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	std::cout &lt;&lt; func_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectHelper</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RFL_STRUCT(n, ...)                                                      \</span></span><br><span class="line"><span class="meta">template <span class="string">&lt;class T&gt;</span>                                                              \</span></span><br><span class="line"><span class="meta">struct ReflectHelper<span class="string">&lt;T, n&gt;</span> &#123;												    \</span></span><br><span class="line"><span class="meta">	static constexpr auto reflectFieldImpl() &#123;									\</span></span><br><span class="line"><span class="meta">		auto&amp; [__VA_ARGS__] = get_global_object<span class="string">&lt;T&gt;</span>();                           \</span></span><br><span class="line"><span class="meta">		auto ref_tup = std::tie(__VA_ARGS__);                                   \</span></span><br><span class="line"><span class="meta">		return check_field(ref_tup);                                            \</span></span><br><span class="line"><span class="meta">	&#125;																		    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">1</span>, f0);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">2</span>, f0, f1);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">3</span>, f0, f1, f2);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">4</span>, f0, f1, f2, f3);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">5</span>, f0, f1, f2, f3, f4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> ptr&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> std::string_view <span class="title">get_member_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> func_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C, T C::*MemberPtr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemberPointerTraits</span>&lt;MemberPtr&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">    <span class="keyword">using</span> class_type = C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> MemberPtr&gt;</span><br><span class="line"><span class="keyword">using</span> member_value_v = <span class="keyword">typename</span> MemberPointerTraits&lt;MemberPtr&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> IsAggregate = std::is_aggregate_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectField</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">reflect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = <span class="built_in">get_private_ptrs</span>(my_wrapper&lt;T&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">size_t</span> N = std::tuple_size_v&lt;<span class="keyword">decltype</span>(tp)&gt;;</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        [&amp;]&lt;<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">            ((found = found || Is_Field&lt;member_value_v&lt;std::<span class="built_in">get</span>&lt;Is&gt;(tp)&gt;&gt;()), ...);</span><br><span class="line">        &#125;(std::make_index_sequence&lt;N&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;IsAggregate T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectField</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reflect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ReflectHelper&lt;T, member_count_v&lt;T&gt;&gt;::<span class="built_in">reflectFieldImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> reflectField_v = ReflectField&lt;T&gt;::<span class="built_in">reflect</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!reflectField_v&lt;Dog&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reflectField_v&lt;Person&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reflectField_v&lt;PersonPrivate&gt;);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = <span class="built_in">get_private_ptrs</span>(my_wrapper&lt;PersonPrivate&gt;&#123;&#125;);</span><br><span class="line">    [&amp;]&lt;<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">        (std::cout &lt;&lt; ... &lt;&lt; get_member_name&lt;std::<span class="built_in">get</span>&lt;Is&gt;(tp)&gt;());</span><br><span class="line">    &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;<span class="keyword">decltype</span>(tp)&gt;&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/09/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84private%E6%88%90%E5%91%98/" data-id="cmagyo5st0001voky8klb07k0" data-title="第六章：编译期反射 private 成员" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" rel="tag">\[Reactive-programming, C++, Modern-Cpp, TMP]</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第五章：编译期反射初探！！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2025-05-09T05:21:27.878Z" itemprop="datePublished">2025-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/">第五章：编译期反射初探！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="第五章：编译期反射初探！"><a href="#第五章：编译期反射初探！" class="headerlink" title="第五章：编译期反射初探！"></a>第五章：编译期反射初探！</h1><p>在前面，我们提到了除了标签分发，还可以通过编译期反射来判断类的成员有没有某个类型。</p>
<blockquote>
<p><strong>反射</strong>是程序在<strong>运行时或编译期</strong>能够**“自我检查、自我操作”的能力**。</p>
</blockquote>
<blockquote>
<p>程序可以“知道自己有哪些类、成员变量、类型信息”，甚至<strong>动态地访问和修改它们</strong>。</p>
</blockquote>
<blockquote>
<p>编译期反射：在<strong>编译期间</strong>就可以分析、枚举、获取类型的成员信息。</p>
</blockquote>
<blockquote>
<p>C++26 正式加入反射：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;meta&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; <span class="type">double</span> y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">void</span> <span class="title">analyze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::meta;</span><br><span class="line">    <span class="keyword">auto</span> info = <span class="built_in">reflexpr</span>(A);  <span class="comment">// 反射出类型信息</span></span><br><span class="line">    <span class="keyword">auto</span> members = <span class="built_in">members_of</span>(info); <span class="comment">// 获取所有成员</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : members) &#123;</span><br><span class="line">        std::<span class="built_in">println</span>(<span class="string">&quot;Member: &#123;&#125;&quot;</span>, <span class="built_in">name_of</span>(m)); <span class="comment">// 打印每个成员的名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前常见的编译期反射库基本都是侵入式的，就是在类内定义一个宏来注册一些方法帮助反射，本章带领大家实现一个简单的非侵入式的编译期反射。<br>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REFL_PRIVATE</span>(PersonPrivate, &amp;PersonPrivate::m_name, &amp;PersonPrivate::m_age, &amp;PersonPrivate::m_male)</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(BasicTest, FieldTest) &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!reaction::reflectField_v&lt;Dog&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reaction::reflectField_v&lt;Person&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(reaction::reflectField_v&lt;PersonPrivate&gt;);</span><br><span class="line">	[&amp;]&lt;<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">    	(std::cout &lt;&lt; ... &lt;&lt; get_member_name&lt;std::<span class="built_in">get</span>&lt;Is&gt;(tp)&gt;());</span><br><span class="line">    &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;<span class="keyword">decltype</span>(tp)&gt;&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要分别对aggregate类型和非聚合类型反射：</p>
<p>在 C++ 中，<code>POD</code>、<code>Trivial</code> 和 <code>Aggregate</code> 类型虽然有重叠，但它们有不同的定义侧重点，理解这些概念对于深入掌握类型系统、内存布局和构造行为非常重要。下面我通过<strong>定义 + 举例 + 差异说明</strong>来讲解这三者的区别。</p>
<h3 id="1-POD（Plain-Old-Data）类型"><a href="#1-POD（Plain-Old-Data）类型" class="headerlink" title="1. POD（Plain Old Data）类型"></a>1. POD（Plain Old Data）类型</h3><p><strong>定义</strong>：满足以下两个条件的类型：</p>
<ul>
<li>是 Trivial 类型（平凡构造&#x2F;析构&#x2F;复制&#x2F;移动）</li>
<li>是 Standard Layout 类型（布局规则简单，兼容 C）</li>
</ul>
<p>📌 <strong>用途</strong>：可与 C 语言数据结构兼容（可 <code>memcpy</code> 拷贝等）</p>
<h3 id="2-Trivial-类型"><a href="#2-Trivial-类型" class="headerlink" title="2. Trivial 类型"></a>2. Trivial 类型</h3><p><strong>定义</strong>：具有以下特征的类型：</p>
<ul>
<li>构造函数、析构函数是编译器默认生成的（且没被用户定义）</li>
<li>拷贝&#x2F;移动构造和赋值操作符也必须是默认的</li>
<li>没有虚函数、没有虚基类</li>
</ul>
<p>📌 <strong>用途</strong>：构造&#x2F;析构开销为零，可 <code>memset</code> 初始化</p>
<h3 id="3-Aggregate-类型"><a href="#3-Aggregate-类型" class="headerlink" title="3. Aggregate 类型"></a>3. Aggregate 类型</h3><p><strong>定义</strong>：聚合类型（C++17 后有所放宽），满足以下条件：</p>
<ul>
<li>没有用户提供的构造函数（注意默认构造函数是 OK 的）</li>
<li>没有 private&#x2F;protected 的非静态成员</li>
<li>没有基类</li>
<li>没有虚函数表（vtable）</li>
</ul>
<p>📌 <strong>用途</strong>：可以使用大括号 <code>&#123;&#125;</code> 初始化所有成员（aggregate initialization）</p>
<p><code>Standard-layout</code>（标准布局类型）是 C++ 中一个与内存布局紧密相关的类型特性，用于确保类型的成员排列方式在不同编译器中行为一致，便于进行底层操作，如 <code>memcpy</code>、C&#x2F;C++ 混合编程等。</p>
<h2 id="Standard-layout-类型定义"><a href="#Standard-layout-类型定义" class="headerlink" title="Standard-layout 类型定义"></a>Standard-layout 类型定义</h2><p>一个类型是 <strong>standard-layout</strong>，必须满足以下条件（C++11 起）：</p>
<ol>
<li>所有非静态成员的访问权限必须一致（都为 <code>public</code>、<code>protected</code> 或 <code>private</code>）；</li>
<li>没有虚函数；</li>
<li>没有虚基类；</li>
<li>所有非静态成员都必须是标准布局类型；</li>
<li>所有基类（如果有）都是标准布局类型；</li>
<li>至多有一个基类；</li>
<li>派生类中第一个非静态成员与其第一个非静态基类不能是同一类型（避免二义性）；</li>
<li>所有非静态数据成员必须在其自身类或基类中声明（不能跨类出现歧义）；</li>
<li>不使用空基类优化（Empty Base Optimization, EBO）；</li>
</ol>
<p>📌 <strong>重点目的</strong>：使类型的内存布局“可预测、紧凑、无重排”。</p>
<hr>
<p>在完成这个浩大的工程之前，让我们先看一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> val&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> std::string_view <span class="title">getFunName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> func_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// int a = 10; </span></span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">getFunName</span>&lt;&amp;global_a&gt;();</span><br><span class="line">    std:: cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="🌟-非类型模板参数（Non-Type-Template-Parameter-NTTP）"><a href="#🌟-非类型模板参数（Non-Type-Template-Parameter-NTTP）" class="headerlink" title="🌟 非类型模板参数（Non-Type Template Parameter, NTTP）"></a>🌟 非类型模板参数（Non-Type Template Parameter, NTTP）</h2><p>C++ 模板的非类型参数允许你在编译时提供具体的值，比如常量、指针、枚举、成员指针等，以此增强模板的灵活性。</p>
<h3 id="🧾-基本语法"><a href="#🧾-基本语法" class="headerlink" title="🧾 基本语法"></a>🧾 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T arr[N]; <span class="comment">// 数组大小为 N</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里，<code>N</code> 是非类型模板参数，用于指定数组大小。</p>
<hr>
<h3 id="🧪-使用示例"><a href="#🧪-使用示例" class="headerlink" title="🧪 使用示例"></a>🧪 使用示例</h3><h4 id="1-常量整数"><a href="#1-常量整数" class="headerlink" title="1. 常量整数"></a>1. 常量整数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;N = &quot;</span> &lt;&lt; N &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printN</span>&lt;<span class="number">10</span>&gt;(); <span class="comment">// 输出 N = 10</span></span><br><span class="line">    <span class="built_in">printN</span>&lt;<span class="number">20</span>&gt;(); <span class="comment">// 输出 N = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-指针或引用"><a href="#2-指针或引用" class="headerlink" title="2. 指针或引用"></a>2. 指针或引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T* ptr&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointerWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer address: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    PointerWrapper&lt;<span class="type">int</span>, &amp;x&gt; pw;</span><br><span class="line">    pw.<span class="built_in">printPointer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-枚举类型"><a href="#3-枚举类型" class="headerlink" title="3. 枚举类型"></a>3. 枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Color c&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(c == Color::Red)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Red\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (c == Color::Green) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Green\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Blue\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printColor</span>&lt;Color::Red&gt;();</span><br><span class="line">    <span class="built_in">printColor</span>&lt;Color::Green&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以借助结构体绑定获取所有成员的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = Person&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们把这三个元素打包成一个tuple遍历不就行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = Person&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> ref_tup = std::<span class="built_in">tie</span>(m1, m2, m3);</span><br></pre></td></tr></table></figure>

<p>问题是非类型参数必须是编译期常量，如果是指针类型指针指向的地址必须是编译期确定的，显然<code>Person&#123;&#125;</code>是一个运行期的值，所以ref_tup也是一个运行期的tuple，那么我们如何获取一个编译期的<code>Person</code>呢？</p>
<p>全局变量由于它的地址是编译时已知的，所以它可以被当成一个编译期常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person g_p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp;&amp; ref = g_p;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp;&amp; ref2 = p; <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我们不可能为每个要反射的类型写一个全局变量，我们可以用一个全局变量模板封装一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> g_value = T&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = g_value&lt;Person&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ref_tup = std::<span class="built_in">tie</span>(m1, m2, m3); <span class="comment">//（这里msvc居然编译不通过，坑啊）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里还有个更好的写法，就是inline static静态成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_wrapper</span> &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">static</span> T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> T&amp; <span class="title">get_global_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_wrapper&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; [m1, m2, m3] = <span class="built_in">get_global_object</span>&lt;Person&gt;();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ref_tup = std::<span class="built_in">tie</span>(m1, m2, m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>inline static</code> 成员变量在 C++17 之后是隐式初始化的（默认初始化或零初始化），并且它的生命周期是整个程序的运行时间（静态存储期）。</li>
<li>由于它是一个全局唯一的实例，它的地址在编译时是已知的（即使它的值可能在运行时初始化）</li>
</ul>
<p>这里的inline是必须的，否则value就只有声明，没有定义，违反ODR原则。<br>ODR（One Definition Rule）是 C++ 中的一条规则，它要求一个类型、函数或者变量在整个程序中只能有一个定义。</p>
<p>至此，我们已经成功一大半了，剩下的工作就是用元编程技术对这个tuple遍历，打印所有的成员名称，并判断是否存在Field类型了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span>&lt;Field&lt;T&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">check_field</span><span class="params">(<span class="type">const</span> Tuple&amp; tuple)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">apply</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp;... args) &#123;</span><br><span class="line">		((found = found || Is_Field&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(args)&gt;&gt;()), ...);</span><br><span class="line">		&#125;, tuple);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_wrapper</span> &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">static</span> T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> T&amp; <span class="title">get_global_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_wrapper&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">getTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; [member1, member2, member3] = g_value&lt;Person&gt;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> ref_tup = std::<span class="built_in">tie</span>(member1, member2, member3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reflectField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> ref_tup = <span class="built_in">getTuple</span>&lt;T&gt;();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">check_field</span>(ref_tup); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(reflectField&lt;Person&gt;);</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = <span class="built_in">getTuple</span>&lt;Person&gt;();</span><br><span class="line">	[&amp;]&lt;<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">    	(std::cout &lt;&lt; ... &lt;&lt; getFunName&lt;&amp;std::<span class="built_in">get</span>&lt;Is&gt;(tp)&gt;());</span><br><span class="line">    &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;<span class="keyword">decltype</span>(tp)&gt;&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题来了，我们在结构化绑定的时候是手动指定了三个成员，那么如何适配N个成员？</p>
<p>首先我们要在编译期计算类型有多少个成员？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyType</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">size_t</span> <span class="title">countMember</span><span class="params">(<span class="keyword">auto</span>&amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!<span class="keyword">requires</span> &#123; T&#123;Args...&#125;; &#125;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>...(Args) - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countMember</span>&lt;T&gt;(Args..., AnyType&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> member_count_v = <span class="built_in">countMember</span>&lt;T&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AnyType的转换函数只需声明就行，requires检测也就是SFINAE技术是在模板参数替换阶段（也就是编译器尝试具体化模板时）进行语法层面的“合法性检查”，而不是运行或完整编译代码。</p>
<h3 id="requires-与-declval-的共性：编译时检查与“伪实例化”"><a href="#requires-与-declval-的共性：编译时检查与“伪实例化”" class="headerlink" title="requires 与 declval&lt;T&gt; 的共性：编译时检查与“伪实例化”"></a><code>requires</code> 与 <code>declval&lt;T&gt;</code> 的共性：编译时检查与“伪实例化”</h3><p><code>requires</code> 和 <code>declval&lt;T&gt;</code> 的共同点在于它们均用于 <strong>编译时</strong> 的类型或表达式合法性检查，且均 <strong>不会生成实际运行时代码</strong>。它们的核心目的是让编译器在模板元编程或概念约束中推导类型的可行性，而非实际构造或操作对象。</p>
<hr>
<h3 id="declval-的“伪实例化”特性"><a href="#declval-的“伪实例化”特性" class="headerlink" title="declval&lt;T&gt; 的“伪实例化”特性"></a><code>declval&lt;T&gt;</code> 的“伪实例化”特性</h3><p><code>declval&lt;T&gt;</code> 是标准库中的一个工具函数模板，其定义大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">add_rvalue_reference_t</span>&lt;T&gt; <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推导 Foo 的成员 value 的类型</span></span><br><span class="line"><span class="keyword">using</span> ValueType = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;Foo&gt;().value); <span class="comment">// ValueType = int</span></span><br></pre></td></tr></table></figure>
<p>它的作用是 <strong>在编译时类型推导的上下文中，生成一个 <code>T</code> 的右值引用</strong>。关键点在于：</p>
<ul>
<li><strong>不调用构造函数</strong>：<code>declval&lt;T&gt;()</code> 不会实际构造 <code>T</code> 的实例，甚至不要求 <code>T</code> 可默认构造或有可访问的构造函数。</li>
<li><strong>未求值上下文</strong>：<code>declval&lt;T&gt;</code> 通常用于 <code>decltype</code>、<code>sizeof</code> 或模板参数推导等 <strong>未求值上下文</strong>（unevaluated contexts），编译器只需知道类型信息，无需生成实际代码。</li>
</ul>
<p>这里使用了模板递归，AnyType可以转换为任意类型，一直用requires检测T构造函数的合法性：</p>
<p>T{}, T{any}, T{any1, any2}, T{any1, any2, any3}，直到失败了即说明参数给多了，此时sizeof…(Args) - 1即为成员数量。</p>
<p>最后在用一个变量模板包装一下，这也符合标准库的习惯。</p>
<p>现在得到了成员数量，如何根据成员数量指定结构体绑定解包的数量，这里要借助宏来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectHelper</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RFL_STRUCT(n, ...)                                                      \</span></span><br><span class="line"><span class="meta">template <span class="string">&lt;class T&gt;</span>                                                              \</span></span><br><span class="line"><span class="meta">struct ReflectHelper<span class="string">&lt;T, n&gt;</span> &#123;												    \</span></span><br><span class="line"><span class="meta">	static constexpr auto reflectFieldImpl() &#123;									\</span></span><br><span class="line"><span class="meta">		auto&amp; [__VA_ARGS__] = get_global_object<span class="string">&lt;T&gt;</span>();                             \</span></span><br><span class="line"><span class="meta">		auto ref_tup = std::tie(__VA_ARGS__);                                   \</span></span><br><span class="line"><span class="meta">		return check_field(ref_tup);                                            \</span></span><br><span class="line"><span class="meta">	&#125;																		    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">1</span>, f0);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">2</span>, f0, f1);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">3</span>, f0, f1, f2);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">4</span>, f0, f1, f2, f3);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">5</span>, f0, f1, f2, f3, f4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reflectField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ReflectHelper&lt;T, member_count_v&lt;T&gt;&gt;::<span class="built_in">reflectFieldImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Field</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonPrivate</span> &#123;</span><br><span class="line">	Field&lt;std::string&gt; m_name;</span><br><span class="line">	Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">	<span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> g_value = T&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> val&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> std::string_view <span class="title">getFunName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __PRETTY_FUNCTION__;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="keyword">constexpr</span> std::string_view func_name = __FUNCSIG__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> pos1 = func_name.<span class="built_in">find</span>(<span class="string">&quot;val = &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (pos1 == std::string_view::npos) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pos2 = func_name.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>, pos1 + <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> (pos2 == std::string_view::npos) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func_name.<span class="built_in">substr</span>(pos1 + <span class="number">6</span>, pos2 - pos1 - <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyType</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">size_t</span> <span class="title">countMember</span><span class="params">(<span class="keyword">auto</span>&amp;&amp;... Args)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!<span class="keyword">requires</span> &#123; T&#123;Args...&#125;; &#125;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>...(Args) - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countMember</span>&lt;T&gt;(Args..., AnyType&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> member_count_v = <span class="built_in">countMember</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Is_Field</span>&lt;Field&lt;T&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">check_field</span><span class="params">(<span class="type">const</span> Tuple&amp; tuple)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">apply</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp;... args) &#123;</span><br><span class="line">		((found = found || Is_Field&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(args)&gt;&gt;()), ...);</span><br><span class="line">		&#125;, tuple);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_wrapper</span> &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">static</span> T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> T&amp; <span class="title">get_global_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_wrapper&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReflectHelper</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RFL_STRUCT(n, ...)                                                      \</span></span><br><span class="line"><span class="meta">template <span class="string">&lt;class T&gt;</span>                                                              \</span></span><br><span class="line"><span class="meta">struct ReflectHelper<span class="string">&lt;T, n&gt;</span> &#123;												    \</span></span><br><span class="line"><span class="meta">	static constexpr auto getTuple() &#123;									        \</span></span><br><span class="line"><span class="meta">		auto&amp; [__VA_ARGS__] = get_global_object<span class="string">&lt;T&gt;</span>();                           \</span></span><br><span class="line"><span class="meta">		return std::tie(__VA_ARGS__);                                           \</span></span><br><span class="line"><span class="meta">	&#125;																		    \</span></span><br><span class="line"><span class="meta">	static constexpr auto reflectFieldImpl() &#123;									\</span></span><br><span class="line"><span class="meta">		auto ref_tup = getTuple();                                              \</span></span><br><span class="line"><span class="meta">		return check_field(ref_tup);                                            \</span></span><br><span class="line"><span class="meta">	&#125;																		    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">1</span>, f0);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">2</span>, f0, f1);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">3</span>, f0, f1, f2);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">4</span>, f0, f1, f2, f3);</span><br><span class="line"><span class="built_in">RFL_STRUCT</span>(<span class="number">5</span>, f0, f1, f2, f3, f4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reflectField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ReflectHelper&lt;T, member_count_v&lt;T&gt;&gt;::<span class="built_in">reflectFieldImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(reflectField&lt;Person&gt;);</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> tp = ReflectHelper&lt;Person, member_count_v&lt;Person&gt;&gt;::<span class="built_in">getTuple</span>();</span><br><span class="line">	[&amp;]&lt;<span class="type">size_t</span>... Is&gt;(std::index_sequence&lt;Is...&gt;) &#123;</span><br><span class="line">    	(std::cout &lt;&lt; ... &lt;&lt; getFunName&lt;&amp;std::<span class="built_in">get</span>&lt;Is&gt;(tp)&gt;());</span><br><span class="line">    &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;<span class="keyword">decltype</span>(tp)&gt;&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/" data-id="cmagyo5sa0000vokyans0h8ue" data-title="第五章：编译期反射初探！" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" rel="tag">\[Reactive-programming, C++, Modern-Cpp, TMP]</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第三章：实现数据源的生命周期管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-05-07T01:54:09.729Z" itemprop="datePublished">2025-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/">第三章：实现数据源的生命周期管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第三章：实现数据源的生命周期管理"><a href="#第三章：实现数据源的生命周期管理" class="headerlink" title="第三章：实现数据源的生命周期管理"></a>第三章：实现数据源的生命周期管理</h1><h2 id="设计目标回顾"><a href="#设计目标回顾" class="headerlink" title="设计目标回顾"></a>设计目标回顾</h2><p>在前两章中，我们已经建立了Reaction框架的基础结构，本章将重点解决以下问题：</p>
<ol>
<li>实现数据源的拷贝和移动语义</li>
<li>使用智能指针和引用计数管理内存</li>
<li>确保用户只持有弱引用，强引用由ObserverGraph统一管理</li>
</ol>
<h2 id="核心设计：桥接模式与智能指针管理"><a href="#核心设计：桥接模式与智能指针管理" class="headerlink" title="核心设计：桥接模式与智能指针管理"></a>核心设计：桥接模式与智能指针管理</h2><h3 id="1-桥接模式的应用"><a href="#1-桥接模式的应用" class="headerlink" title="1. 桥接模式的应用"></a>1. 桥接模式的应用</h3><p>桥接模式（Bridge Pattern）是面向对象设计中的经典模式，其核心思想是将抽象（Abstraction）与实现（Implementation）分离，使二者可以独立变化。这种分离通过组合（Composition）而非继承（Inheritance）实现，是”组合优于继承”原则的典型体现。</p>
<p>在Reaction框架中，我们通过以下结构实现桥接模式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReactType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">React</span> &#123; <span class="comment">/* 抽象接口层 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TriggerPolicy, <span class="keyword">typename</span> InvalidStrategy, <span class="keyword">typename</span> Type, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReactImpl</span> : <span class="keyword">public</span> Expression&lt;TriggerPolicy, Type, Args...&gt;,</span><br><span class="line">                  <span class="keyword">public</span> InvalidStrategy &#123; <span class="comment">/* 实现层 */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>桥接模式的优势</strong>：</p>
<ul>
<li>接口(<code>React</code>)与实现(<code>ReactImpl</code>)可以独立变化</li>
<li>隐藏了复杂的模板参数和实现细节</li>
<li>用户只需与简洁的<code>React</code>接口交互</li>
</ul>
<h3 id="2-智能指针与引用计数"><a href="#2-智能指针与引用计数" class="headerlink" title="2. 智能指针与引用计数"></a>2. 智能指针与引用计数</h3><p>我们采用三级引用管理策略：</p>
<ol>
<li><strong>强引用</strong>：由<code>ObserverGraph</code>统一管理，确保活跃数据源不会被意外释放</li>
<li><strong>弱引用</strong>：用户持有的<code>React</code>对象内部使用<code>std::weak_ptr</code></li>
<li><strong>弱引用计数</strong>：<code>ReactImpl</code>内部维护<code>m_weakRefCount</code>，用于跟踪弱引用数量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">React</span> &#123;</span><br><span class="line">    std::weak_ptr&lt;ReactType&gt; m_weakPtr; <span class="comment">// 用户只持有弱引用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReactImpl</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; m_weakRefCount&#123;<span class="number">0</span>&#125;; <span class="comment">// 弱引用计数器</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现关键点"><a href="#实现关键点" class="headerlink" title="实现关键点"></a>实现关键点</h2><h3 id="1-拷贝语义实现"><a href="#1-拷贝语义实现" class="headerlink" title="1. 拷贝语义实现"></a>1. 拷贝语义实现</h3><p>拷贝构造和拷贝赋值需要正确处理弱引用计数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React的拷贝构造函数</span></span><br><span class="line"><span class="built_in">React</span>(<span class="type">const</span> React &amp;other) : <span class="built_in">m_weakPtr</span>(other.m_weakPtr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">        p-&gt;<span class="built_in">addWeakRef</span>(); <span class="comment">// 增加弱引用计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React的拷贝赋值运算符</span></span><br><span class="line">React &amp;<span class="keyword">operator</span>=(<span class="type">const</span> React &amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">            p-&gt;<span class="built_in">releaseWeakRef</span>(); <span class="comment">// 释放旧引用</span></span><br><span class="line">        m_weakPtr = other.m_weakPtr;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">            p-&gt;<span class="built_in">addWeakRef</span>(); <span class="comment">// 增加新引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-移动语义实现"><a href="#2-移动语义实现" class="headerlink" title="2. 移动语义实现"></a>2. 移动语义实现</h3><p>移动操作需要转移所有权并重置原对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React的移动构造函数</span></span><br><span class="line"><span class="built_in">React</span>(React &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">m_weakPtr</span>(std::<span class="built_in">move</span>(other.m_weakPtr)) &#123;</span><br><span class="line">    other.m_weakPtr.<span class="built_in">reset</span>(); <span class="comment">// 原对象放弃所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React的移动赋值运算符</span></span><br><span class="line">React &amp;<span class="keyword">operator</span>=(React &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> p = m_weakPtr.<span class="built_in">lock</span>())</span><br><span class="line">            p-&gt;<span class="built_in">releaseWeakRef</span>();</span><br><span class="line">        m_weakPtr = std::<span class="built_in">move</span>(other.m_weakPtr);</span><br><span class="line">        other.m_weakPtr.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-弱引用计数管理"><a href="#3-弱引用计数管理" class="headerlink" title="3. 弱引用计数管理"></a>3. 弱引用计数管理</h3><p><code>ReactImpl</code>需要提供弱引用计数的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWeakRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_weakRefCount++; <span class="comment">// 原子操作增加计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseWeakRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--m_weakRefCount == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ObserverGraph::<span class="built_in">getInstance</span>().<span class="built_in">removeNode</span>(<span class="keyword">this</span>-&gt;<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Safe-Bool-Idiom（安全布尔惯用法）的历史"><a href="#Safe-Bool-Idiom（安全布尔惯用法）的历史" class="headerlink" title="Safe Bool Idiom（安全布尔惯用法）的历史"></a><strong>Safe Bool Idiom（安全布尔惯用法）的历史</strong></h3><p>在 C++11 之前，C++ 没有直接支持安全的布尔转换机制，导致开发者需要设计各种技巧来防止隐式转换带来的问题。<strong>Safe Bool Idiom</strong> 就是在这个背景下诞生的，它的演进可以分为三个阶段：</p>
<hr>
<h2 id="1-原始-operator-bool-的问题（C-98-03）"><a href="#1-原始-operator-bool-的问题（C-98-03）" class="headerlink" title="1. 原始 operator bool 的问题（C++98&#x2F;03）"></a><strong>1. 原始 <code>operator bool</code> 的问题（C++98&#x2F;03）</strong></h2><p>在早期 C++ 中，如果一个类定义了 <code>operator bool()</code>，它会允许 <strong>隐式转换</strong>，导致许多意外的行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">isValid</span>(); &#125; <span class="comment">// 隐式转换</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FileHandle file;</span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">/* OK */</span> &#125;</span><br><span class="line"><span class="type">int</span> x = file; <span class="comment">// 糟糕！file 被隐式转换成 bool，再转成 int（可能非预期）</span></span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ul>
<li>允许 <code>FileHandle</code> 隐式转换成 <code>bool</code>，进而可能参与算术运算（如 <code>file + 5</code>）。</li>
<li>可能与其他类型发生意外的隐式转换（如 <code>if (file == nullptr)</code> 可能编译通过，但逻辑错误）。</li>
</ul>
<hr>
<h2 id="2-Safe-Bool-Idiom-的诞生（C-03-时代的解决方案）"><a href="#2-Safe-Bool-Idiom-的诞生（C-03-时代的解决方案）" class="headerlink" title="2. Safe Bool Idiom 的诞生（C++03 时代的解决方案）"></a><strong>2. Safe Bool Idiom 的诞生（C++03 时代的解决方案）</strong></h2><p>为了避免隐式转换的问题，C++ 开发者发明了 <strong>Safe Bool Idiom</strong>，主要思路是：</p>
<ul>
<li><strong>不直接返回 <code>bool</code>，而是返回一个指向成员函数的指针</strong>（通常是一个私有的、不可调用的函数）。</li>
<li>由于函数指针不能隐式转换成 <code>int</code> 或其他类型，但仍然可以在 <code>if</code>、<code>while</code> 等布尔上下文中使用。</li>
</ul>
<p><strong>实现方式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(FileHandle::*SafeBoolType)</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">SafeBoolType</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValid</span>() ? &amp;FileHandle::dummy : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125; <span class="comment">// 仅用于安全布尔转换</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FileHandle file;</span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">/* OK */</span> &#125;</span><br><span class="line"><span class="type">int</span> x = file; <span class="comment">// 编译错误！无法隐式转换</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>防止了隐式转换成 <code>int</code> 或其他类型。</li>
<li>仍然可以在布尔上下文中使用。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>代码复杂，引入了额外的成员函数和类型定义。</li>
<li>仍然有一些极端情况可能不安全（如 <code>delete file</code> 可能编译通过，但行为未定义）。</li>
</ul>
<hr>
<h2 id="3-C-11-的-explicit-operator-bool（现代解决方案）"><a href="#3-C-11-的-explicit-operator-bool（现代解决方案）" class="headerlink" title="3. C++11 的 explicit operator bool（现代解决方案）"></a><strong>3. C++11 的 <code>explicit operator bool</code>（现代解决方案）</strong></h2><p>C++11 引入了 <strong><code>explicit</code> 转换运算符</strong>，直接解决了 Safe Bool Idiom 的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">isValid</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FileHandle file;</span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">/* OK */</span> &#125;</span><br><span class="line"><span class="type">int</span> x = file; <span class="comment">// 编译错误！必须显式转换</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>语法简洁，不需要额外的辅助类型。</li>
<li>完全防止隐式转换，只允许在布尔上下文中使用。</li>
<li>被标准库广泛采用（如 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 都使用 <code>explicit operator bool</code>）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !m_weakPtr.<span class="built_in">expired</span>(); <span class="comment">// Returns true if the pointer is not null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试用例分析"><a href="#测试用例分析" class="headerlink" title="测试用例分析"></a>测试用例分析</h2><p>让我们看看测试用例如何验证这些功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestCopy) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(bb); &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + dsds; &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dds_copy = dds;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;113.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;113.140000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;223.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;223.140000&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test for moving data sources</span></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestMove) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(bb); &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + dsds; &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dds_copy = std::<span class="built_in">move</span>(dds);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;113.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dds));</span><br><span class="line">    <span class="built_in">EXPECT_THROW</span>(dds.<span class="built_in">get</span>(), std::runtime_error);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds_copy.<span class="built_in">get</span>(), <span class="string">&quot;223.140000&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dds));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现注意事项"><a href="#实现注意事项" class="headerlink" title="实现注意事项"></a>实现注意事项</h2><ol>
<li><strong>线程安全</strong>：所有引用计数操作使用<code>std::atomic</code>保证线程安全</li>
<li><strong>异常安全</strong>：移动操作标记为<code>noexcept</code>，确保不会在转移所有权时抛出异常</li>
<li><strong>空状态检查</strong>：通过<code>operator bool()</code>允许用户检查对象有效性</li>
<li><strong>资源释放</strong>：当弱引用计数归零时，通知ObserverGraph可以释放资源</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章通过桥接模式和智能指针的巧妙结合，实现了：</p>
<ol>
<li>安全的拷贝和移动语义</li>
<li>自动化的内存管理</li>
<li>清晰的接口与实现分离</li>
<li>高效的响应式更新机制</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/" data-id="cmadrzd5800007ekybliyhoi5" data-title="第三章：实现数据源的生命周期管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第四章：让数据源作为成员变量" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/" class="article-date">
  <time class="dt-published" datetime="2025-05-03T05:56:59.613Z" itemprop="datePublished">2025-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">第四章：让数据源作为成员变量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="第四章：让数据源作为成员变量"><a href="#第四章：让数据源作为成员变量" class="headerlink" title="第四章：让数据源作为成员变量"></a>第四章：让数据源作为成员变量</h1><p>在本章中，我们将实现 <code>constVar</code>、<code>action</code> 和 <code>field</code>。</p>
<p>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestConst) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">constVar</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">5.14</span>);</span><br><span class="line">    <span class="comment">// b.value(4.14); // compile error;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestAction) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> at = reaction::<span class="built_in">action</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; aa &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; bb &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;, a, b);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="keyword">public</span> reaction::FieldBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age, <span class="type">bool</span> male)</span><br><span class="line">        : <span class="built_in">m_name</span>(<span class="built_in">field</span>(name)), <span class="built_in">m_age</span>(<span class="built_in">field</span>(age)), <span class="built_in">m_male</span>(male) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">        *m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_age.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        *m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">    <span class="type">bool</span> m_male;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(BasicTest, FieldTest) &#123;</span><br><span class="line">    Person person&#123;<span class="string">&quot;lummy&quot;</span>, <span class="number">18</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = reaction::<span class="built_in">var</span>(person);</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="keyword">auto</span> pp) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + pp.<span class="built_in">getName</span>(); &#125;, a, p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="string">&quot;1lummy&quot;</span>);</span><br><span class="line">    p-&gt;<span class="built_in">setName</span>(<span class="string">&quot;lummy-new&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="string">&quot;1lummy-new&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="深度实现解析：基于继承的字段管理系统"><a href="#深度实现解析：基于继承的字段管理系统" class="headerlink" title="深度实现解析：基于继承的字段管理系统"></a>深度实现解析：基于继承的字段管理系统</h2><h3 id="一、核心架构设计"><a href="#一、核心架构设计" class="headerlink" title="一、核心架构设计"></a>一、核心架构设计</h3><h4 id="1-1-类关系图谱"><a href="#1-1-类关系图谱" class="headerlink" title="1.1 类关系图谱"></a>1.1 类关系图谱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class FieldBase&#123;</span><br><span class="line">        &lt;&lt;abstract&gt;&gt;</span><br><span class="line">        +uint64_t m_id</span><br><span class="line">        +field(T&amp;&amp;) React</span><br><span class="line">        +~FieldBase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Person&#123;</span><br><span class="line">        +Field&lt;std::string&gt; m_name</span><br><span class="line">        +Field&lt;int&gt; m_age</span><br><span class="line">        +bool m_male</span><br><span class="line">        +getName() string</span><br><span class="line">        +setName(string)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class FieldGraph&#123;</span><br><span class="line">        -unordered_map&lt;uint64_t, unordered_set&lt;NodePtr&gt;&gt; m_fieldMap</span><br><span class="line">        +addObj()</span><br><span class="line">        +deleteObj()</span><br><span class="line">        +setField()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ReactImpl&#123;</span><br><span class="line">        -T m_value</span><br><span class="line">        +updateObservers()</span><br><span class="line">        +addObserver()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FieldBase &lt;|-- Person</span><br><span class="line">    FieldGraph o-- ReactImpl</span><br><span class="line">    Person *-- ReactImpl</span><br></pre></td></tr></table></figure>

<h3 id="二、关键实现细节"><a href="#二、关键实现细节" class="headerlink" title="二、关键实现细节"></a>二、关键实现细节</h3><h4 id="2-1-字段注册机制（FieldBase）"><a href="#2-1-字段注册机制（FieldBase）" class="headerlink" title="2.1 字段注册机制（FieldBase）"></a>2.1 字段注册机制（FieldBase）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FieldBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">field</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建响应式节点（AlwaysTrigger策略）</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::make_shared&lt;ReactImpl&lt;AlwaysTrigger, DirectCloseStrategy, std::<span class="type">decay_t</span>&lt;T&gt;&gt;&gt;(</span><br><span class="line">            std::forward&lt;T&gt;(t)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册到全局字段图（关键点1）</span></span><br><span class="line">        FieldGraph::<span class="built_in">getInstance</span>().<span class="built_in">addObj</span>(m_id, ptr-&gt;<span class="built_in">getShared</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> React&#123;ptr&#125;;  <span class="comment">// 返回React包装</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FieldBase</span>() &#123;</span><br><span class="line">        <span class="comment">// 对象销毁时自动清理（关键点2）</span></span><br><span class="line">        FieldGraph::<span class="built_in">getInstance</span>().<span class="built_in">deleteObj</span>(m_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 唯一标识生成器（模板化实现）</span></span><br><span class="line">    UniqueID&lt;FieldBase&gt; m_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>实现要点</strong>：</p>
<ol>
<li>每个派生类实例自动获得唯一ID</li>
<li>字段构造时自动注册到所属对象</li>
<li>析构时自动解除注册</li>
</ol>
<h4 id="2-2-字段关系图（FieldGraph增强实现）"><a href="#2-2-字段关系图（FieldGraph增强实现）" class="headerlink" title="2.2 字段关系图（FieldGraph增强实现）"></a>2.2 字段关系图（FieldGraph增强实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FieldGraph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setField</span><span class="params">(<span class="type">uint64_t</span> id, NodePtr objPtr)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> it = m_fieldMap.<span class="built_in">find</span>(id); it != m_fieldMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 双向观察建立（关键点3）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; node : it-&gt;second) &#123;</span><br><span class="line">                <span class="comment">// 对象观察字段变更</span></span><br><span class="line">                node-&gt;<span class="built_in">addObserver</span>(objPtr);</span><br><span class="line">                <span class="comment">// 字段观察对象变更</span></span><br><span class="line">                objPtr-&gt;<span class="built_in">addObserver</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex m_mutex;  <span class="comment">// 线程安全保护</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">uint64_t</span>, std::unordered_set&lt;NodePtr&gt;&gt; m_fieldMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>观察关系建立流程</strong>：</p>
<ol>
<li>对象创建var时触发setField调用</li>
<li>遍历对象的所有注册字段</li>
<li>建立对象与字段的双向观察：<ul>
<li>字段变更 → 通知所属对象</li>
<li>对象变更 → 通知所有字段</li>
</ul>
</li>
</ol>
<h4 id="2-3-var模板的特化处理"><a href="#2-3-var模板的特化处理" class="headerlink" title="2.3 var模板的特化处理"></a>2.3 var模板的特化处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">var</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RawT = std::<span class="type">decay_t</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译期类型检查（关键点4）</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;FieldBase, RawT&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::make_shared&lt;ReactImpl&lt;AlwaysTrigger, DirectCloseStrategy, RawT&gt;&gt;(</span><br><span class="line">            std::forward&lt;T&gt;(t)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟建立观察关系（关键点5）</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; graph = FieldGraph::<span class="built_in">getInstance</span>();</span><br><span class="line">        graph.<span class="built_in">setField</span>(ptr-&gt;<span class="built_in">get</span>().<span class="built_in">getId</span>(), ptr-&gt;<span class="built_in">getShared</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> React&#123;ptr&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 常规处理流程</span></span><br><span class="line">        <span class="keyword">return</span> React&#123;std::make_shared&lt;ReactImpl&lt;AlwaysTrigger, DirectCloseStrategy, RawT&gt;&gt;(</span><br><span class="line">            std::forward&lt;T&gt;(t))</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计决策分析</strong>：</p>
<ul>
<li>选择<code>is_base_of_v</code>而非反射的原因：<ol>
<li><strong>编译期确定性</strong>：避免运行时类型检查开销</li>
<li><strong>更好的类型安全</strong>：强制使用FieldBase派生类</li>
<li><strong>简化实现</strong>：无需复杂反射基础设施</li>
</ol>
</li>
</ul>
<h3 id="三、生命周期管理策略"><a href="#三、生命周期管理策略" class="headerlink" title="三、生命周期管理策略"></a>三、生命周期管理策略</h3><h4 id="3-1-对象注册流程"><a href="#3-1-对象注册流程" class="headerlink" title="3.1 对象注册流程"></a>3.1 对象注册流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User</span><br><span class="line">    participant Person</span><br><span class="line">    participant FieldGraph</span><br><span class="line">    participant ReactImpl</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Person: 创建实例</span><br><span class="line">    Person-&gt;&gt;FieldBase: 构造（生成m_id）</span><br><span class="line">    loop 初始化字段</span><br><span class="line">        Person-&gt;&gt;FieldBase: field(&quot;lummy&quot;)</span><br><span class="line">        FieldBase-&gt;&gt;ReactImpl: 创建字段实例</span><br><span class="line">        FieldBase-&gt;&gt;FieldGraph: addObj(m_id, fieldPtr)</span><br><span class="line">    end</span><br><span class="line">    User-&gt;&gt;var模板: 创建数据源</span><br><span class="line">    var模板-&gt;&gt;FieldGraph: setField(m_id, objPtr)</span><br><span class="line">    FieldGraph-&gt;&gt;ReactImpl: 建立双向观察</span><br></pre></td></tr></table></figure>

<h4 id="3-2-对象销毁流程"><a href="#3-2-对象销毁流程" class="headerlink" title="3.2 对象销毁流程"></a>3.2 对象销毁流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User</span><br><span class="line">    participant Person</span><br><span class="line">    participant FieldGraph</span><br><span class="line">    participant ReactImpl</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Person: 析构实例</span><br><span class="line">    Person-&gt;&gt;FieldBase: 析构</span><br><span class="line">    FieldBase-&gt;&gt;FieldGraph: deleteObj(m_id)</span><br><span class="line">    FieldGraph-&gt;&gt;ReactImpl: 移除所有关联字段</span><br><span class="line">    ReactImpl-&gt;&gt;Observers: 自动解除观察关系</span><br></pre></td></tr></table></figure>

<p>此外，为了在 <code>var</code> 接收到自定义类型时，识别其继承 <code>FieldBase</code> 并自动调用 <code>setField</code>，建议在 <code>VarImpl</code> 构造中使用 <code>std::is_base_of_v&lt;FieldBase, T&gt;</code> 判断并分发。</p>
<h3 id="模板元编程常用技法：标签分发（Tag-Dispatching）"><a href="#模板元编程常用技法：标签分发（Tag-Dispatching）" class="headerlink" title="模板元编程常用技法：标签分发（Tag Dispatching）"></a><strong>模板元编程常用技法：标签分发（Tag Dispatching）</strong></h3><ul>
<li><strong>核心思想</strong>：通过定义空结构体（标签）表示类型特性，利用函数重载或模板特化分发到不同实现。</li>
<li><strong>典型场景</strong>：标准库算法根据迭代器类型（如 <code>std::input_iterator_tag</code>）选择最优实现。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义标签</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InputTag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RandomAccessTag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(Iter begin, Iter end, InputTag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 针对输入迭代器的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(Iter begin, Iter end, RandomAccessTag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 针对随机访问迭代器的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数：通过 traits 提取标签并分发</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(Iter begin, Iter end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Tag = <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::iterator_category;</span><br><span class="line">    <span class="built_in">algorithm</span>(begin, end, Tag&#123;&#125;); <span class="comment">// 标签分发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后，说明一下 <code>decltype(auto)</code> 的使用场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 React 对象中获取引用时：</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">getRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getReference</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>decltype(auto)</code> 是 C++14 引入的一个类型推导工具，用于根据表达式的值类型（value category）精确推导变量或返回值的类型。</p>
<h3 id="一、基本作用"><a href="#一、基本作用" class="headerlink" title="一、基本作用"></a>一、基本作用</h3><p>它的作用可以理解为：</p>
<ul>
<li><code>decltype(auto)</code> 会<strong>完全照搬</strong>表达式的类型，包括是否为引用、是否为 <code>const</code>。</li>
<li>和 <code>auto</code> 不同，<code>decltype(auto)</code> 不会移除引用或 <code>const</code> 修饰。</li>
</ul>
<h3 id="二、示例说明"><a href="#二、示例说明" class="headerlink" title="二、示例说明"></a>二、示例说明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = rx;            <span class="comment">// a 的类型是 int（引用被移除）</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) b = rx;  <span class="comment">// b 的类型是 int&amp;（引用保留）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">foo</span>();            <span class="comment">// x 是 int（右值引用被移除）</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) y = <span class="built_in">foo</span>();  <span class="comment">// y 是 int&amp;&amp;（保留右值引用）</span></span><br></pre></td></tr></table></figure>

<h3 id="三、主要应用场景"><a href="#三、主要应用场景" class="headerlink" title="三、主要应用场景"></a>三、主要应用场景</h3><ol>
<li><strong>函数返回值类型推导</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getX</span>(); <span class="comment">// 保留返回引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用 <code>auto</code>，返回值会被拷贝；用 <code>decltype(auto)</code>，可以保留引用或右值引用的属性。</p>
<ol start="2">
<li><strong>模板中精确转发和返回类型</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">forwardValue</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;T&gt;(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/" data-id="cmadrzd5s00067ekygbwbeqb6" data-title="第四章：让数据源作为成员变量" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" rel="tag">\[Reactive-programming, C++, Modern-Cpp, TMP]</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第二章：让数据流起来！依赖节点管理的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B5%B7%E6%9D%A5%EF%BC%81%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2025-04-23T08:06:30.263Z" itemprop="datePublished">2025-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B5%B7%E6%9D%A5%EF%BC%81%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/">第二章：让数据流起来！依赖节点管理的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第二章：让数据流起来！依赖节点管理的实现"><a href="#第二章：让数据流起来！依赖节点管理的实现" class="headerlink" title="第二章：让数据流起来！依赖节点管理的实现"></a>第二章：让数据流起来！依赖节点管理的实现</h1><p>在本章中，我们将实现 <code>ObserverNode</code> 和 <code>ObserverGraph</code>，从而能够正确传播数据源的调用链。</p>
<p>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestCommonUse) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(a.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(dsds); &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;14.140000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">5.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;25.140000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>众所周知，设计模式中有一个赫赫有名的<strong>观察者模式</strong>，而我们本章要做的，实际上就是一个观察者模式的实现。</p>
<p>观察者模式需要一个<strong>观察容器</strong>，但问题在于——我们的<strong>数据源是任意类型</strong>的，那么，如何把这些不同类型的数据源放进同一个容器中呢？</p>
<p>这就需要用到**类型擦除（Type Erasure）**的技术。</p>
<p>类型擦除是一种常见的编程技术，它允许你在<strong>保持类型安全</strong>的前提下，处理多种不同类型的数据，而无需在编译时知道这些类型的具体信息。</p>
<p>在 C++ 中，类型擦除是实现 <strong>“鸭子类型（Duck Typing）”</strong> 的核心手段之一。</p>
<p>所谓鸭子类型，是动态类型系统中的一种编程思想，其名字源自那句经典谚语：</p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那它就可以被认为是鸭子。”</p>
</blockquote>
<p>在鸭子类型的语义中，<strong>我们关心的是对象“能做什么”，而不是“它是什么”</strong>：</p>
<ul>
<li>不关心它是不是 <code>Duck</code> 类；</li>
<li>只关心它能不能 <code>swim()</code>、<code>walk()</code>、<code>quack()</code>。</li>
</ul>
<p>换句话说，鸭子类型强调的是<strong>行为匹配</strong>而非<strong>类型匹配</strong>，关注点在于对象的<strong>接口与能力</strong>，而非其<strong>所属类型</strong>。</p>
<p>具体地说，类型擦除是一种运行时多态技术，C++中有几种常见的类型擦除实现方式:</p>
<ul>
<li>虚函数</li>
<li><code>std::function</code></li>
<li><code>std::any</code></li>
</ul>
<p>我们今天用<strong>虚函数</strong>和<code>std::function</code>来实现类型擦除，并做一下性能对比。</p>
<h2 id="虚函数实现"><a href="#虚函数实现" class="headerlink" title="虚函数实现"></a>虚函数实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">valueChanged</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateObservers</span><span class="params">(Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">        (<span class="type">void</span>)(..., args.<span class="built_in">addObserver</span>(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;observer : m_observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">valueChanged</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;ObserverNode*&gt; m_observers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="折叠表达式解释："><a href="#折叠表达式解释：" class="headerlink" title="折叠表达式解释："></a>折叠表达式解释：</h3><p><code>(..., args.addObserver(this))</code> 这里是一个<strong>折叠表达式</strong>，属于<strong>一元左折叠</strong>，展开为一个逗号表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arg<span class="number">1.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), arg<span class="number">2.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), arg<span class="number">3.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), ...)</span><br></pre></td></tr></table></figure>

<p>逗号表达式的特点是：<strong>会依次执行前面所有项的语句，并返回最后一项的值</strong>。当然，这里也可以写成右折叠 <code>(args.addObserver(this), ...)</code>，由于逗号操作符本身是顺序执行的，其顺序不影响结果。但如果使用的是 <code>-</code> 或 <code>/</code> 等非交换的操作符，折叠方向就会影响结果。</p>
<p>为什么前面要加 <code>(void)</code>？</p>
<p>这是一个<strong>强制类型转换</strong>，将整个逗号表达式的结果转为 <code>void</code> 类型，这就形成了一个<strong>弃置表达式</strong>（discarded-value expression）。这意味着我们<strong>不关心表达式的返回值，只关心它的副作用</strong>（即每次调用 <code>addObserver(this)</code> 的效果）。</p>
<p>如果 <code>addObserver</code> 有返回值，使用 <code>(void)</code> 明确告知编译器“我不关心这个返回值”，可以避免可能出现的 <strong>“未使用返回值”警告</strong>，这是一种典型的<strong>防御性编程</strong>技巧。</p>
<p>在 C++17 之前，还不能直接使用折叠表达式，因此通常借助 <code>std::initializer_list</code> 实现类似功能的 workaround，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)std::initializer_list&lt;<span class="type">int</span>&gt;&#123;(args.<span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>)...&#125;;</span><br></pre></td></tr></table></figure>

<p>借助初始化列表的展开能力，<code>(args.addObserver(this), 0)...</code> 会生成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(arg<span class="number">1.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>), (arg<span class="number">2.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>), (arg<span class="number">3.</span><span class="built_in">addObserver</span>(<span class="keyword">this</span>), <span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>我在学习现代 C++ 的时候，曾把 <strong>折叠表达式</strong> 和 <strong>包展开（parameter pack expansion）</strong> 搞混。其实两者有明显的差别，下面是几种常见的包展开形式：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>示例表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>递归函数调用</td>
<td><code>print_all(args...)</code></td>
<td>递归展开参数包</td>
</tr>
<tr>
<td>初始化容器</td>
<td><code>std::tuple&#123;args...&#125;</code></td>
<td>直接展开到初始化列表</td>
</tr>
<tr>
<td>模板参数列表</td>
<td><code>std::is_same_v&lt;Args, T&gt;...</code></td>
<td>展开到模板参数</td>
</tr>
<tr>
<td>完美转发</td>
<td><code>std::forward&lt;Args&gt;(args)...</code></td>
<td>保持值类别进行转发</td>
</tr>
</tbody></table>
<p>C++ 的包展开规则要求：<strong>展开必须发生在明确的模板或初始化上下文中</strong>，比如函数调用、初始化列表、模板参数等。<br>但对于需要运算符参与的场景，包展开本身就无法单独使用，这时就要使用折叠表达式。</p>
<h2 id="DataSource-的-value-方法实现"><a href="#DataSource-的-value-方法实现" class="headerlink" title="DataSource 的 value 方法实现"></a>DataSource 的 value 方法实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSource</span> : <span class="keyword">public</span> Expression&lt;Type, Args...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ValueType = Expression&lt;Type, Args...&gt;::ValueType;</span><br><span class="line">    <span class="keyword">using</span> ExprType = Expression&lt;Type, Args...&gt;::ExprType;</span><br><span class="line">    <span class="keyword">using</span> Expression&lt;Type, Args...&gt;::Expression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">        <span class="title">requires</span> <span class="params">(std::is_convertible_v&lt;std::<span class="type">decay_t</span>&lt;T&gt;, ValueType&gt; &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::is_same_v&lt;ExprType, VarExpr&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">value</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">updateValue</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类型萃取与别名传递"><a href="#类型萃取与别名传递" class="headerlink" title="类型萃取与别名传递"></a>类型萃取与别名传递</h3><p>至于最后提到的 <code>ValueType</code>，它是模板元编程中最经典的惯用技法之一，核心思想是一种：</p>
<blockquote>
<p><strong>类型萃取（type extraction） + 别名传递（alias propagation）</strong></p>
</blockquote>
<p>举例来说，在 STL 标准模板库中，迭代器类型通常通过如下方式萃取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::iterator_traits&lt;Iter&gt;::value_type</span><br></pre></td></tr></table></figure>

<p>这样可以<strong>统一地提取出某个迭代器的值类型</strong>。然后把这个 <code>value_type</code> 传递到容器或算法中，在执行算法时，就能根据容器中不同的 <code>value_type</code> 做出相应优化：</p>
<ul>
<li><code>std::vector</code> 是随机访问迭代器，可以直接跳跃；</li>
<li><code>std::list</code> 是单向或双向迭代器，只能一步一步前进。</li>
</ul>
<p>这种机制让 C++ 在泛型编程中具备了强大的类型适配能力。</p>
<p>requires可以用concept封装一下，这样可以提高可读性和复用性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> ConvertCC = std::is_convertible_v&lt;std::<span class="type">decay_t</span>&lt;T&gt;, std::<span class="type">decay_t</span>&lt;U&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> VarExprCC = std::is_same_v&lt;T, VarExpr&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="性能压力测试"><a href="#性能压力测试" class="headerlink" title="性能压力测试"></a>性能压力测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProcessedData</span> &#123;</span><br><span class="line">    std::string info;</span><br><span class="line">    <span class="type">int</span> checksum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, StressTest) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> reaction;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create var-data sources</span></span><br><span class="line">    <span class="keyword">auto</span> base1 = <span class="built_in">var</span>(<span class="number">1</span>);                <span class="comment">// Integer source</span></span><br><span class="line">    <span class="keyword">auto</span> base2 = <span class="built_in">var</span>(<span class="number">2.0</span>);              <span class="comment">// Double source</span></span><br><span class="line">    <span class="keyword">auto</span> base3 = <span class="built_in">var</span>(<span class="literal">true</span>);             <span class="comment">// Boolean source</span></span><br><span class="line">    <span class="keyword">auto</span> base4 = <span class="built_in">var</span>(std::string&#123;<span class="string">&quot;3&quot;</span>&#125;); <span class="comment">// String source</span></span><br><span class="line">    <span class="keyword">auto</span> base5 = <span class="built_in">var</span>(<span class="number">4</span>);                <span class="comment">// Integer source</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 1: Add integer and double</span></span><br><span class="line">    <span class="keyword">auto</span> layer1 = <span class="built_in">calc</span>([](<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;, base1, base2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 2: Multiply or divide based on the flag</span></span><br><span class="line">    <span class="keyword">auto</span> layer2 = <span class="built_in">calc</span>([](<span class="type">double</span> val, <span class="type">bool</span> flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag ? val * <span class="number">2</span> : val / <span class="number">2</span>;</span><br><span class="line">    &#125;, layer1, base3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 3: Convert double value to a string</span></span><br><span class="line">    <span class="keyword">auto</span> layer3 = <span class="built_in">calc</span>([](<span class="type">double</span> val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Value:&quot;</span> + std::<span class="built_in">to_string</span>(val);</span><br><span class="line">    &#125;, layer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 4: Append integer to string</span></span><br><span class="line">    <span class="keyword">auto</span> layer4 = <span class="built_in">calc</span>([](<span class="type">const</span> std::string &amp;s, <span class="type">const</span> std::string &amp;s4) &#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;_&quot;</span> + s4;</span><br><span class="line">    &#125;, layer3, base4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 5: Get the length of the string</span></span><br><span class="line">    <span class="keyword">auto</span> layer5 = <span class="built_in">calc</span>([](<span class="type">const</span> std::string &amp;s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">length</span>();</span><br><span class="line">    &#125;, layer4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 6: Create a vector of double values</span></span><br><span class="line">    <span class="keyword">auto</span> layer6 = <span class="built_in">calc</span>([](<span class="type">size_t</span> len, <span class="type">int</span> b5) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len, b5);</span><br><span class="line">    &#125;, layer5, base5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 7: Sum all elements in the vector</span></span><br><span class="line">    <span class="keyword">auto</span> layer7 = <span class="built_in">calc</span>([](<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;, layer6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 8: Create a ProcessedData object with checksum and info</span></span><br><span class="line">    <span class="keyword">auto</span> layer8 = <span class="built_in">calc</span>([](<span class="type">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessedData&#123;<span class="string">&quot;ProcessedData&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(sum)&#125;;</span><br><span class="line">    &#125;, layer7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer 9: Combine info and checksum into a string</span></span><br><span class="line">    <span class="keyword">auto</span> layer9 = <span class="built_in">calc</span>([](<span class="type">const</span> ProcessedData &amp;calc) &#123;</span><br><span class="line">        <span class="keyword">return</span> calc.info + <span class="string">&quot;|&quot;</span> + std::<span class="built_in">to_string</span>(calc.checksum);</span><br><span class="line">    &#125;, layer8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Final layer: Add &quot;Final:&quot; prefix to the result</span></span><br><span class="line">    <span class="keyword">auto</span> finalLayer = <span class="built_in">calc</span>([](<span class="type">const</span> std::string &amp;s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Final:&quot;</span> + s;</span><br><span class="line">    &#125;, layer9);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ITERATIONS = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">auto</span> start = steady_clock::<span class="built_in">now</span>(); <span class="comment">// Start measuring time</span></span><br><span class="line">    <span class="comment">// Perform stress test for the given number of iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; ++i) &#123;</span><br><span class="line">        <span class="comment">// Update base sources with new values</span></span><br><span class="line">        *base1 = i % <span class="number">100</span>;</span><br><span class="line">        *base2 = (i % <span class="number">100</span>) * <span class="number">0.1</span>;</span><br><span class="line">        *base3 = i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the expected result for the given input</span></span><br><span class="line">        std::string expected = [&amp;]() &#123;</span><br><span class="line">            <span class="type">double</span> l1 = base<span class="number">1.</span><span class="built_in">get</span>() + base<span class="number">2.</span><span class="built_in">get</span>();                        <span class="comment">// Add base1 and base2</span></span><br><span class="line">            <span class="type">double</span> l2 = base<span class="number">3.</span><span class="built_in">get</span>() ? l1 * <span class="number">2</span> : l1 / <span class="number">2</span>;                    <span class="comment">// Multiply or divide based on base3</span></span><br><span class="line">            std::string l3 = <span class="string">&quot;Value:&quot;</span> + std::<span class="built_in">to_string</span>(l2);               <span class="comment">// Convert to string</span></span><br><span class="line">            std::string l4 = l3 + <span class="string">&quot;_&quot;</span> + base<span class="number">4.</span><span class="built_in">get</span>();                      <span class="comment">// Append base1</span></span><br><span class="line">            <span class="type">size_t</span> l5 = l<span class="number">4.l</span>ength();                                      <span class="comment">// Get string length</span></span><br><span class="line">            <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">l6</span><span class="params">(l5, base<span class="number">5.</span>get())</span></span>;                         <span class="comment">// Create vector of length &#x27;l5&#x27;</span></span><br><span class="line">            <span class="type">int</span> l7 = std::<span class="built_in">accumulate</span>(l<span class="number">6.</span><span class="built_in">begin</span>(), l<span class="number">6.</span><span class="built_in">end</span>(), <span class="number">0</span>);            <span class="comment">// Sum vector values</span></span><br><span class="line">            ProcessedData l8&#123;<span class="string">&quot;ProcessedData&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(l7)&#125;;      <span class="comment">// Create ProcessedData object</span></span><br><span class="line">            std::string l9 = l<span class="number">8.</span>info + <span class="string">&quot;|&quot;</span> + std::<span class="built_in">to_string</span>(l<span class="number">8.</span>checksum); <span class="comment">// Combine info and checksum</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Final:&quot;</span> + l9;                                         <span class="comment">// Add final prefix</span></span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print progress every 10,000 iterations</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span> &amp;&amp; finalLayer.<span class="built_in">get</span>() == expected) &#123;</span><br><span class="line">            <span class="keyword">auto</span> dur = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(steady_clock::<span class="built_in">now</span>() - start);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Progress: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; ITERATIONS</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; dur.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms)\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output the final results of the stress test</span></span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(steady_clock::<span class="built_in">now</span>() - start);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=== Stress Test Results ===\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Iterations: &quot;</span> &lt;&lt; ITERATIONS &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Total time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Avg time per update: &quot;</span></span><br><span class="line">              &lt;&lt; duration.<span class="built_in">count</span>() / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(ITERATIONS) &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::function实现类型擦除：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt; &amp;f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_observers.<span class="built_in">emplace_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateObservers</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt; &amp;f, Args &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        (..., args.<span class="built_in">addObserver</span>(f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;observer : m_observers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">observer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; m_observers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B5%B7%E6%9D%A5%EF%BC%81%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cm9trkbhx0000psky87dv5oet" data-title="第二章：让数据流起来！依赖节点管理的实现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-第一章：让代码跑起来！构建响应式框架的起点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A9%E4%BB%A3%E7%A0%81%E8%B7%91%E8%B5%B7%E6%9D%A5%EF%BC%81%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B5%B7%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2025-04-12T15:03:53.216Z" itemprop="datePublished">2025-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A9%E4%BB%A3%E7%A0%81%E8%B7%91%E8%B5%B7%E6%9D%A5%EF%BC%81%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B5%B7%E7%82%B9/">第一章：让代码跑起来！构建响应式框架的起点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第一章：让代码跑起来！构建响应式框架的起点"><a href="#第一章：让代码跑起来！构建响应式框架的起点" class="headerlink" title="第一章：让代码跑起来！构建响应式框架的起点"></a>第一章：让代码跑起来！构建响应式框架的起点</h1><p>在本章中，我们将从零开始搭建 Reaction 响应式框架的基本工程结构，并实现几个关键的核心组件：<code>DataSource</code>、<code>Expression</code> 和 <code>Resource</code>。这些组件将构成我们响应式框架的计算骨架。</p>
<p>我们的目标是让如下代码成功编译并通过测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(a.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line"><span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(dsds); &#125;, a, ds);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;14.140000&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="1-项目结构搭建"><a href="#1-项目结构搭建" class="headerlink" title="1. 项目结构搭建"></a>1. 项目结构搭建</h2><p>使用 CMake 构建项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reaction/</span><br><span class="line">├── include/</span><br><span class="line">│   └── reaction/</span><br><span class="line">│       ├── dataSource.h</span><br><span class="line">│       ├── expression.h</span><br><span class="line">│       └── resource.h</span><br><span class="line">├── test/</span><br><span class="line">│   └── test.cpp</span><br><span class="line">├── CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="1-1-CMakeLists-txt-示例"><a href="#1-1-CMakeLists-txt-示例" class="headerlink" title="1.1 CMakeLists.txt 示例"></a>1.1 CMakeLists.txt 示例</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(reaction VERSION <span class="number">1.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(/W4 /GR-)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_compile_options</span>(-Wall -Wextra -pedantic -fno-rtti -std=c++<span class="number">2</span>a)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Choose the type of build.&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> INTERFACE)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>::<span class="variable">$&#123;PROJECT_NAME&#125;</span> ALIAS <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> INTERFACE</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(GTest)</span><br><span class="line"><span class="keyword">if</span>(GTest_FOUND)</span><br><span class="line">    <span class="keyword">enable_testing</span>()</span><br><span class="line">    <span class="keyword">file</span>(GLOB TEST_SOURCES <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>/*.cpp)</span><br><span class="line">    <span class="keyword">add_executable</span>(runTests <span class="variable">$&#123;TEST_SOURCES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(runTests PRIVATE GTest::GTest GTest::Main <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">add_test</span>(NAME reactionTest <span class="keyword">COMMAND</span> runTests)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;GTest not found, skipping tests.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MSVC (Windows)</strong>:<ul>
<li><code>/W4</code>: 高警告级别</li>
<li><code>/GR-</code>: 禁用 RTTI (运行时类型信息)</li>
</ul>
</li>
<li><strong>其他编译器</strong>:<ul>
<li><code>-Wall -Wextra -pedantic</code>: 严格警告</li>
<li><code>-fno-rtti</code>: 禁用 RTTI</li>
<li><code>-std=c++2a</code>: 指定 C++20 标准 (GCC&#x2F;Clang 的旧名称)</li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> INTERFACE)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>::<span class="variable">$&#123;PROJECT_NAME&#125;</span> ALIAS <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个 INTERFACE 库 (不构建实际二进制文件)</li>
<li>为库创建别名，符合现代 CMake 目标命名规范</li>
</ul>
<hr>
<h2 id="2-实现核心组件"><a href="#2-实现核心组件" class="headerlink" title="2. 实现核心组件"></a>2. 实现核心组件</h2><h3 id="2-1-DataSource：数据源管理器"><a href="#2-1-DataSource：数据源管理器" class="headerlink" title="2.1 DataSource：数据源管理器"></a>2.1 DataSource：数据源管理器</h3><p><code>DataSource</code> 是用户操作响应式变量的入口，暴露出 <code>get()</code>等各种接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSource</span> : <span class="keyword">public</span> Expression&lt;T, Args...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getValue</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>为什么要采用这种继承的设计模式</strong></p>
</blockquote>
<ol>
<li>数据源本身是一个表达式，这里符合<strong>is-a</strong>的关系</li>
<li><strong>解耦逻辑</strong>，将不同类型的数据源的处理逻辑放在Expression类中处理，DataSource本身只负责用户交互的部分</li>
<li><strong>空基类优化（EBO）</strong><br> 当基类为空时（如只有类型定义无数据成员），继承可完全消除存储开销<br> 组合方式会因C++对象布局规则（每个对象必须有唯一地址）产生至少1个指针的开销</div></li>
</ol>
<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>为什么此处必须要 <code>this-&gt;getValue()</code>，否则编译不通过</strong></p>
</blockquote>
<p>要解释这个问题，首先要从 C++ 模板的编译机制说起——<br><strong>两阶段查找（Two-Phase Lookup）</strong> 和 <strong>延迟实例化（Delayed Instantiation）</strong> 机制：</p>
<hr>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">memberFunc</span>();  <span class="comment">// ✅ 编译通过（待决名）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设前面没有 IncompleteType 的定义</span></span><br><span class="line">    IncompleteType* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">memberFunc</span>();  <span class="comment">// ❌ 编译错误：</span></span><br><span class="line">                        <span class="comment">//    IncompleteType 是非待决名，且是不完整类型，无法调用成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>第一阶段（语法分析阶段）</strong></p>
<ul>
<li>编译器只检查模板本身的<strong>语法</strong>（如 <code>ptr-&gt;memberFunc()</code> 是否符合基本语法规则）。</li>
<li>不检查 <code>T</code> 是否完整，也不检查 <code>memberFunc</code> 是否存在（因为 <code>T</code> 可能是任何类型）。</li>
</ul>
</li>
<li><p><strong>第二阶段（模板实例化阶段）</strong></p>
<ul>
<li>当 <code>bar&lt;IncompleteType&gt;(ptr)</code> 被调用时，编译器尝试实例化 <code>bar</code>。</li>
<li>如果 <code>IncompleteType</code> 仍然不完整，或者没有 <code>memberFunc</code>，则实例化失败，报错。</li>
</ul>
</li>
</ol>
<p>在模板中，如果一个名称（变量、函数、类型等）的解析<strong>依赖于模板参数</strong>，则称为 <strong>待决名（Dependent Name）</strong>。<br>编译器在第一阶段（模板定义阶段）不会立即解析它，而是在第二阶段（模板实例化阶段）再确定其含义。</p>
<hr>
<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunc</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memberFunc</span>();       <span class="comment">// ❌ 非待决名，立即查找失败</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">memberFunc</span>(); <span class="comment">// ✅ 待决名，延迟到实例化阶段再查找</span></span><br><span class="line">        Base&lt;T&gt;::<span class="built_in">memberFunc</span>(); <span class="comment">//  另一种正确写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>memberFunc()</code></strong></p>
<ul>
<li>由于不依赖任何模板参数，被视为<strong>非待决名</strong>，会在编译时的语义分析阶段立即查找。</li>
<li>此时 <code>Base&lt;T&gt;</code> 尚未实例化，查找失败，编译报错。</li>
</ul>
</li>
<li><p><strong><code>this-&gt;memberFunc()</code></strong></p>
<ul>
<li>等价于 <code>MyClass&lt;T&gt; * -&gt; memberFunc()</code>，依赖于模板类型参数 <code>T</code>，属于<strong>待决名</strong>。</li>
<li>编译器在实例化 <code>MyClass&lt;T&gt;</code> 时，再去查找 <code>memberFunc()</code>，此时 <code>Base&lt;T&gt;</code> 已实例化，可正常调用。</li>
</ul>
</li>
</ul>
</div>

<h3 id="2-2-Expression：表达式封装器"><a href="#2-2-Expression：表达式封装器" class="headerlink" title="2.2 Expression：表达式封装器"></a>2.2 Expression：表达式封装器</h3><p>用于管理依赖计算逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExpressionTraits</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExpressionTraits</span>&lt;DataSource&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExpressionTraits</span>&lt;DataSource&lt;Fun, Args...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = std::<span class="type">invoke_result_t</span>&lt;Fun, <span class="keyword">typename</span> ExpressionTraits&lt;Args&gt;::Type...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> ExpressionTraits&lt;DataSource&lt;Fun, Args...&gt;&gt;::Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fun, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> : <span class="keyword">public</span> Resource&lt;ReturnType&lt;Fun, Args...&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... A&gt;</span><br><span class="line">    <span class="built_in">Expression</span>(F &amp;&amp;f, A &amp;&amp;...args) : <span class="built_in">m_func</span>(std::forward&lt;F&gt;(f)), <span class="built_in">m_args</span>(std::forward&lt;Args&gt;(args)...) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">evaluate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> result = [&amp;]&lt;std::<span class="type">size_t</span>... I&gt;(std::index_sequence&lt;I...&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">invoke</span>(m_func, std::<span class="built_in">get</span>&lt;I&gt;(m_args).<span class="built_in">get</span>()...);</span><br><span class="line">        &#125;(std::make_index_sequence&lt;std::tuple_size_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(m_args)&gt;&gt;&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">updateValue</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Fun m_func;</span><br><span class="line">    std::tuple&lt;Args...&gt; m_args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span>&lt;Type&gt; : <span class="keyword">public</span> Resource&lt;Type&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Expression</span>(T &amp;&amp;t) : <span class="built_in">Resource</span>&lt;Type&gt;(std::forward&lt;T&gt;(t)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using Resource&lt;Type&gt;::Resource; //或者用C++11的继承构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>std::invoke_result_t</code>有个坑，我们后面会修改它</p>
</blockquote>
<blockquote>
<p>使用了 C++20 的 lambda 模板参数<code>[&amp;]&lt;std::size_t... I&gt;(...)</code>，这种语法被称为 “immediate lambda”</p>
</blockquote>
<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>为什么类模板的类型参数不能是万能引用</strong></p>
</blockquote>
<p>我学习现代C++的时候，思考过这个问题，函数模板和类模板既然都可以推导，为什么函数模板可以引用折叠推导为万能引用，而类模板不行？</p>
<p><strong>函数模板参数推导（Function Template Argument Deduction）（C++98就已经支持）</strong><br><strong>类模板参数推导（CTAD, Class Template Argument Deduction）（C++17才开始支持）</strong></p>
<p><strong>为什么CTAD需要单独引入？</strong><br><strong>技术复杂度不同</strong>：</p>
<ul>
<li>函数模板推导仅涉及单次调用</li>
<li>类模板推导需要协调所有构造函数的参数组合（需要Deduction Guides）</li>
</ul>
<p><strong>如果允许类模板参数直接作为万能引用</strong>，会导致哪些严重的类型安全问题和技术陷阱。</p>
<p>假设C++允许这样的语法（实际非法）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DangerousHolder</span> &#123;</span><br><span class="line">    T resource;  <span class="comment">// 成员是引用类型（可能是左值或右值引用）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DangerousHolder</span>(T&amp;&amp; r) : <span class="built_in">resource</span>(std::forward&lt;T&gt;(r)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="类型系统崩溃"><a href="#类型系统崩溃" class="headerlink" title="类型系统崩溃"></a>类型系统崩溃</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例2：类型意外变为引用</span></span><br><span class="line"><span class="function">DangerousHolder <span class="title">holder1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 假设T=int，则成员类型为int&amp;&amp;</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function">DangerousHolder <span class="title">holder2</span><span class="params">(x)</span></span>;     <span class="comment">// 假设T=int&amp;，则成员类型为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(holder<span class="number">1.</span>resource), <span class="type">int</span>&amp;&amp;&gt;); <span class="comment">// 通过</span></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(holder<span class="number">2.</span>resource), <span class="type">int</span>&amp;&gt;);  <span class="comment">// 通过</span></span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>相同模板实例化<code>DangerousHolder&lt;int&gt;</code>会产生<strong>两种完全不同的成员类型</strong></li>
<li>违反类模板”生成确定类型”的基本原则</li>
</ul>
<p><strong>对比安全实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SafeHolder&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 成员永远是int类型</span></span><br><span class="line"><span class="function">SafeHolder&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(x)</span></span>;   <span class="comment">// 同上，即使传入左值</span></span><br></pre></td></tr></table></figure>

<p>引用折叠规则不适合贯穿整个对象生命周期：</p>
<p><strong>C++ 的引用折叠规则（&amp; &amp; → &amp;、&amp;&amp; &amp; → &amp;、&amp;&amp; &amp;&amp; → &amp;&amp; 等）设计初衷是为了函数参数推导时临时使用。<br>如果把它用到类模板参数层面，就得让编译器在模板定义、实例化、特化时都执行复杂的折叠，极易引入混乱和歧义。</strong></p>
<hr>
<p>而函数模板的万能引用之所以能避免类模板参数的问题，关键在于其<strong>临时性</strong>和<strong>作用域局限性</strong>。这种设计差异源于两者在C++中的根本角色不同。以下是具体分析：</p>
<h4 id="核心差异：生存周期与作用域"><a href="#核心差异：生存周期与作用域" class="headerlink" title="核心差异：生存周期与作用域"></a>核心差异：生存周期与作用域</h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>函数模板万能引用</th>
<th>类模板成员引用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用时间</strong></td>
<td>仅在函数调用期间有效</td>
<td>伴随整个对象生命周期</td>
</tr>
<tr>
<td><strong>存储要求</strong></td>
<td>不涉及长期存储</td>
<td>可能成为对象状态的一部分</td>
</tr>
<tr>
<td><strong>类型确定性</strong></td>
<td>每次调用独立推导</td>
<td>必须与类定义统一</td>
</tr>
</tbody></table>
<h4 id="1-无法形成长期持有"><a href="#1-无法形成长期持有" class="headerlink" title="1. 无法形成长期持有"></a>1. 无法形成长期持有</h4><p><strong>临时性与作用域限制</strong></p>
<ul>
<li>函数内部传入的右值或左值引用，只在函数执行期间存在，之后立即销毁或恢复。</li>
<li>类成员一旦持有引用，就要长期管理它的生命周期，容易出错。</li>
</ul>
<h4 id="2-类型推导隔离性"><a href="#2-类型推导隔离性" class="headerlink" title="2. 类型推导隔离性"></a>2. 类型推导隔离性</h4><p><strong>推导隔离性</strong></p>
<ul>
<li>每次函数调用都是独立的模板推导：<code>foo(x)</code> 和 <code>foo(3.14)</code> 分别会推导为 <code>T=int&amp;</code> 和 <code>T=double</code>，互不影响。</li>
<li>类模板在同一次实例化内，必须保证“相同模板参数→相同类型布局”，否则就打破了类型安全。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">foo</span>(x);     <span class="comment">// 本次T=int&amp;</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">3.14</span>);  <span class="comment">// 本次T=double</span></span><br></pre></td></tr></table></figure>

<p>不会出现类模板中”一个实例化对应多种成员类型”的矛盾</p>
<ul>
<li>函数模板和类模板服务于不同场景：函数模板强调“临时、一次性”的推导与转发；类模板强调“持久、稳定”的类型定义。</li>
<li>语言设计者为了保证语法简洁、一致、可维护，特意将“引用折叠”机制局限在了函数模板参数中，不允许在类模板参数列表出现。</li>
</ul>
</div>


<h3 id="2-3-Resource：值资源管理器"><a href="#2-3-Resource：值资源管理器" class="headerlink" title="2.3 Resource：值资源管理器"></a>2.3 Resource：值资源管理器</h3><p>用于底层数据的读写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ResourceBase</span>() :</span><br><span class="line">        <span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">ResourceBase</span>(T &amp;&amp;t) :</span><br><span class="line">        <span class="built_in">m_ptr</span>(std::<span class="built_in">make_unique</span>&lt;Type&gt;(std::forward&lt;T&gt;(t))) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ptr) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Attempt to get a null pointer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateValue</span><span class="params">(T &amp;&amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ptr) &#123;</span><br><span class="line">            m_ptr = std::<span class="built_in">make_unique</span>&lt;Type&gt;(std::forward&lt;T&gt;(t));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *m_ptr = std::forward&lt;T&gt;(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique&lt;Type&gt; m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div style="border: 10px solid #ddd; padding: 10px; border-radius: 5px; margin: 10px 0; background:rgba(240, 235, 235, 0);">

<blockquote>
<p><strong>八股文整理：为什么要make_shared, make_unique而不直接使用构造函数</strong></p>
</blockquote>
<p>在 C++ 中，<code>std::make_shared</code> 和 <code>std::make_unique</code> 是创建智能指针的推荐方式，相较于直接使用构造函数（如 <code>std::shared_ptr&lt;T&gt;(new T)</code> 或 <code>std::unique_ptr&lt;T&gt;(new T)</code>），它们具有以下优势：</p>
<hr>
<h4 id="1-代码简洁性"><a href="#1-代码简洁性" class="headerlink" title="1. 代码简洁性"></a>1. <strong>代码简洁性</strong></h4><ul>
<li><code>make_shared</code> 和 <code>make_unique</code> 通过模板参数推导，允许<strong>一行代码完成对象的构造和智能指针的初始化</strong>，避免重复书写类型。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = std::<span class="built_in">make_shared</span>&lt;Foo&gt;();  <span class="comment">// 简洁</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Foo&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;    <span class="comment">// 需要重复写 Foo</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-异常安全"><a href="#2-异常安全" class="headerlink" title="2. 异常安全"></a>2. <strong>异常安全</strong></h4><ul>
<li>如果直接使用 <code>new</code> 并将裸指针传递给智能指针构造函数，可能在<strong>内存分配成功但智能指针构造未完成时</strong>发生异常，导致内存泄漏。</li>
<li><code>make_shared</code> 和 <code>make_unique</code> 是<strong>原子操作</strong>（分配内存和构造智能指针），避免了这一问题。</li>
<li>示例（不安全的情况）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">shared_ptr</span>&lt;Foo&gt;(<span class="keyword">new</span> <span class="built_in">Foo</span>(arg1, arg2)); <span class="comment">// 可能泄漏</span></span><br></pre></td></tr></table></figure>
改用 <code>make_shared</code> 后：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;Foo&gt;(arg1, arg2); <span class="comment">// 更安全</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-性能优化（仅针对-make-shared）"><a href="#3-性能优化（仅针对-make-shared）" class="headerlink" title="3. 性能优化（仅针对 make_shared）"></a>3. <strong>性能优化（仅针对 <code>make_shared</code>）</strong></h4><ul>
<li><code>std::shared_ptr</code> 需要维护两块内存：<ol>
<li><strong>对象本身的内存</strong>（存储 <code>Foo</code> 的数据）。</li>
<li><strong>控制块的内存</strong>（存储引用计数、弱计数等）。</li>
</ol>
</li>
<li>直接使用 <code>new</code> 时，这两块内存是<strong>分开分配</strong>的（两次内存操作）。</li>
<li><code>make_shared</code> 会<strong>合并这两块内存</strong>，通过单次分配完成，减少了内存开销和分配时间。</div></li>
</ul>
<hr>
<h2 id="3-封装-API：reaction-var-和-reaction-calc"><a href="#3-封装-API：reaction-var-和-reaction-calc" class="headerlink" title="3. 封装 API：reaction::var 和 reaction::calc"></a>3. 封装 API：reaction::var 和 reaction::calc</h2><p>为了方便用户使用，我们提供统一入口函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> reaction &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">var</span><span class="params">(T &amp;&amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DataSource</span>&lt;T&gt;(std::forward&lt;T&gt;(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">calc</span><span class="params">(F f, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DataSource&lt;std::<span class="type">decay_t</span>&lt;F&gt;, std::<span class="type">decay_t</span>&lt;Args&gt;...&gt;(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意这里的<code>decay_t</code>，类模板应该生成常规类型（regular types），而引用类型会破坏值语义的完整性，影响后面的类型推导、特化</strong></p>
</blockquote>
<hr>
<h2 id="4-编写测试：test-test-var-cpp"><a href="#4-编写测试：test-test-var-cpp" class="headerlink" title="4. 编写测试：test&#x2F;test_var.cpp"></a>4. 编写测试：test&#x2F;test_var.cpp</h2><p>我们用 GTest 验证功能是否正常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reaction/dataSource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ReactionTest, TestCalc) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(a.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="type">int</span> aa, <span class="type">double</span> bb) &#123; <span class="keyword">return</span> aa + bb; &#125;, a, b);</span><br><span class="line">    <span class="keyword">auto</span> dds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> dsds) &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(dsds); &#125;, a, ds);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_FLOAT_EQ</span>(ds.<span class="built_in">get</span>(), <span class="number">4.14</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(dds.<span class="built_in">get</span>(), <span class="string">&quot;14.140000&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>通过本章内容，我们实现了 Reaction 框架的第一个可运行版本，包括基本的数据源管理、表达式求值和测试验证，下一章我们开始实现数据源的依赖传播</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A9%E4%BB%A3%E7%A0%81%E8%B7%91%E8%B5%B7%E6%9D%A5%EF%BC%81%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B5%B7%E7%82%B9/" data-id="cm9slj60o0000uokyf4nm8879" data-title="第一章：让代码跑起来！构建响应式框架的起点" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Reaction响应式框架介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/12/Reaction%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2025-04-12T13:05:45.491Z" itemprop="datePublished">2025-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Reaction/">Reaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/12/Reaction%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/">从零实现响应式框架——基本概念和设计思路</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="走进响应式编程：从理念到-C-20-实现-——-Reaction-响应式框架介绍"><a href="#走进响应式编程：从理念到-C-20-实现-——-Reaction-响应式框架介绍" class="headerlink" title="走进响应式编程：从理念到 C++20 实现 —— Reaction 响应式框架介绍"></a>走进响应式编程：从理念到 C++20 实现 —— Reaction 响应式框架介绍</h1><p>在现代软件开发中，响应式编程正逐步成为构建数据驱动应用的重要范式。本文将带你深入了解响应式编程的核心理念，比较当前主流响应式框架的优劣，并探讨为何在 C++20 环境下实现响应式框架尤为必要。随后，我们将介绍 Reaction 框架的整体设计思路与架构布局。</p>
<hr>
<h2 id="🎯-本教程面向谁？"><a href="#🎯-本教程面向谁？" class="headerlink" title="🎯 本教程面向谁？"></a>🎯 本教程面向谁？</h2><p>本教程适合以下人群阅读：</p>
<ul>
<li><strong>具备 C++ 基础的开发者</strong>：希望通过实战提升对语言本身的理解，掌握更现代的 C++20 编程范式。</li>
<li><strong>对现代 C++ 感兴趣的学习者</strong>：希望学习 Concepts、constexpr、模板元编程等特性在工程中的实际用法。</li>
<li><strong>正在求职或准备面试的 C++ 开发者</strong>：通过构建完整框架提升项目能力，积累可展示的实战经验。</li>
<li><strong>希望了解响应式编程原理的人</strong>：尤其是在 Vue、React 等前端框架中有相关经验，想了解背后机制在 C++ 中的实现方式。</li>
</ul>
<p>如果你希望从零构建一个现代化、类型安全、高性能的响应式框架，那么这份系列教程将为你提供系统的思路与代码支撑。</p>
<hr>
<h2 id="1-什么是响应式编程？"><a href="#1-什么是响应式编程？" class="headerlink" title="1. 什么是响应式编程？"></a>1. 什么是响应式编程？</h2><p>响应式编程是一种以“数据驱动视图”和“自动更新”为核心的编程范式。其目标是当底层数据发生变化时，系统能够自动刷新所有依赖于该数据的部分，从而避免繁琐的手动更新逻辑，提升系统的实时性、稳定性和维护性。</p>
<h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul>
<li><p><strong>数据流（Data Flow）</strong><br>将数据视作一系列随时间变化的值流，当某个值更新时，其变化将自动传播到所有依赖者。</p>
</li>
<li><p><strong>依赖追踪（Dependency Tracking）</strong><br>系统自动记录数据之间的依赖关系，确保任何变化都能触发对应更新操作。</p>
</li>
<li><p><strong>声明式编程（Declarative Programming）</strong><br>开发者只需声明“数据之间的关系”，而不必显式编写“如何更新”的逻辑，框架会自动完成这些工作。</p>
</li>
</ul>
<hr>
<h2 id="2-主流响应式框架对比分析"><a href="#2-主流响应式框架对比分析" class="headerlink" title="2. 主流响应式框架对比分析"></a>2. 主流响应式框架对比分析</h2><p>目前在不同编程语言生态中，已经诞生了众多响应式框架。它们各具特色，覆盖前端开发、后端服务乃至系统编程领域。</p>
<h3 id="2-1-JavaScript-TypeScript-生态"><a href="#2-1-JavaScript-TypeScript-生态" class="headerlink" title="2.1 JavaScript &#x2F; TypeScript 生态"></a>2.1 JavaScript &#x2F; TypeScript 生态</h3><ul>
<li><p><strong>RxJS</strong></p>
<ul>
<li>优点：操作符丰富，支持异步流组合，适合事件密集型场景。</li>
<li>缺点：学习曲线陡峭，操作链复杂，调试困难。</li>
</ul>
</li>
<li><p><strong>Vue.js &#x2F; React</strong></p>
<ul>
<li>优点：通过响应式状态管理实现 UI 自动更新，极大简化前端开发。</li>
<li>缺点：响应机制封装较深，底层调试不易。</li>
</ul>
</li>
</ul>
<h3 id="2-2-Java-生态"><a href="#2-2-Java-生态" class="headerlink" title="2.2 Java 生态"></a>2.2 Java 生态</h3><ul>
<li><strong>Reactor &#x2F; RxJava</strong><ul>
<li>优点：强大的流处理能力，适用于高并发和分布式系统。</li>
<li>缺点：设计复杂，资源消耗较大，学习成本高。</li>
</ul>
</li>
</ul>
<h3 id="2-3-C-生态"><a href="#2-3-C-生态" class="headerlink" title="2.3 C# 生态"></a>2.3 C# 生态</h3><ul>
<li><strong>Rx.NET</strong><ul>
<li>优点：集成度高、语法简洁，非常适合异步编程。</li>
<li>缺点：内存管理需谨慎，性能上不及底层语言。</li>
</ul>
</li>
</ul>
<h3 id="2-4-C-生态"><a href="#2-4-C-生态" class="headerlink" title="2.4 C++ 生态"></a>2.4 C++ 生态</h3><ul>
<li><p><strong>RxCpp</strong></p>
<ul>
<li>优点：API 接近 Rx 系列设计，功能完备，支持复杂流式操作。</li>
<li>缺点：语法冗长、模板嵌套复杂，难以在简洁场景中高效应用。</li>
</ul>
</li>
<li><p><strong>其他尝试性库（如 Bacon++）</strong></p>
<ul>
<li>优点：探索性设计，验证响应式模型在 C++ 中的可行性。</li>
<li>缺点：社区活跃度低，文档不足，稳定性待提升。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-为什么选择-C-20-来实现响应式框架？"><a href="#3-为什么选择-C-20-来实现响应式框架？" class="headerlink" title="3. 为什么选择 C++20 来实现响应式框架？"></a>3. 为什么选择 C++20 来实现响应式框架？</h2><p>C++20 带来了诸多颠覆性特性，为响应式框架的高效实现奠定了基础：</p>
<ul>
<li><p><strong>Concepts 与 constexpr</strong><br>强类型约束和编译期计算能力显著增强，使得类型安全与性能优化并存。</p>
</li>
<li><p><strong>模板元编程能力增强</strong><br>支持更强大的编译期逻辑，能够构建“零运行时成本”的依赖追踪机制。</p>
</li>
<li><p><strong>模块化支持</strong><br>提高项目结构清晰度，减少编译依赖与时间成本，有助于大规模架构设计。</p>
</li>
</ul>
<p>借助这些新特性，我们可以打造一个编译期友好、性能卓越、类型安全的响应式框架，填补 C++ 生态在 UI 状态管理和数据依赖表达方面的空白。</p>
<hr>
<h2 id="4-Reaction-响应式框架-——-设计理念与结构"><a href="#4-Reaction-响应式框架-——-设计理念与结构" class="headerlink" title="4. Reaction 响应式框架 —— 设计理念与结构"></a>4. Reaction 响应式框架 —— 设计理念与结构</h2><p>Reaction is a blazing-fast, modern C++20 header-only reactive framework that brings React&#x2F;Vue-style dataflow to native C++ – perfect for UI, game logic, and more.</p>
<h3 id="🎯-Focused-on-UI-Dataflow-Management"><a href="#🎯-Focused-on-UI-Dataflow-Management" class="headerlink" title="🎯 Focused on UI Dataflow Management"></a>🎯 <strong>Focused on UI Dataflow Management</strong></h3><ul>
<li><strong>Pure Data-Driven Updates</strong> – Optimized for <strong>one-way binding</strong> (Model → View)</li>
<li><strong>No Event Emitters</strong> – Changes propagate <strong>only through data dependencies</strong>, avoiding callback hell</li>
<li><strong>Predictable Updates</strong> – Strict <strong>top-down dataflow</strong> like React&#x2F;Vue, but with zero runtime overhead</li>
</ul>
<h4 id="Ideal-For"><a href="#Ideal-For" class="headerlink" title="Ideal For:"></a><strong>Ideal For:</strong></h4><p>✅ <strong>MVVM&#x2F;MVC UI Architectures</strong><br>✅ <strong>Game Object Properties</strong><br>✅ <strong>Form Validation Chains</strong><br>✅ <strong>Animation State Machines</strong></p>
<h3 id="🚀-Performance-Optimized"><a href="#🚀-Performance-Optimized" class="headerlink" title="🚀 Performance Optimized"></a>🚀 Performance Optimized</h3><ul>
<li><strong>Zero-cost abstractions</strong> through template metaprogramming</li>
<li>Minimal runtime overhead with <strong>smart change propagation</strong></li>
<li>Propagation efficiency <strong>at the level of millions per second</strong></li>
</ul>
<h3 id="🔗-Intelligent-Dependency-Management"><a href="#🔗-Intelligent-Dependency-Management" class="headerlink" title="🔗 Intelligent Dependency Management"></a>🔗 Intelligent Dependency Management</h3><ul>
<li>Automatic <strong>DAG detection</strong> and cycle prevention</li>
<li>Fine-grained <strong>change propagation control</strong></li>
<li>Configurable <strong>caching strategies</strong></li>
</ul>
<h3 id="🛡️-Safety-Guarantees"><a href="#🛡️-Safety-Guarantees" class="headerlink" title="🛡️ Safety Guarantees"></a>🛡️ Safety Guarantees</h3><ul>
<li>Compile-time <strong>type checking</strong> with C++20 concepts</li>
<li>Safe <strong>value semantics</strong> throughout the framework</li>
<li>Framework manages object lifetime internally</li>
</ul>
<h3 id="🧩-Extensible-Design"><a href="#🧩-Extensible-Design" class="headerlink" title="🧩 Extensible Design"></a>🧩 Extensible Design</h3><table>
<thead>
<tr>
<th>Feature</th>
<th>Options</th>
</tr>
</thead>
<tbody><tr>
<td>Trigger Policy</td>
<td>ValueChange, Threshold, Timer, Custom</td>
</tr>
<tr>
<td>Invalidation</td>
<td>Direct, KeepCalculate, LastValue</td>
</tr>
</tbody></table>
<h3 id="📦-Requirements"><a href="#📦-Requirements" class="headerlink" title="📦 Requirements"></a>📦 Requirements</h3><ul>
<li><strong>Compiler</strong>: C++20 compatible (GCC 10+, Clang 12+, MSVC 19.30+)</li>
<li><strong>Build System</strong>: CMake 3.15+</li>
</ul>
<h2 id="🛠-Installation"><a href="#🛠-Installation" class="headerlink" title="🛠 Installation"></a>🛠 Installation</h2><p>To build and install the <code>reaction</code> reactive framework, follow the steps below:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lumia431/reaction.git &amp;&amp; <span class="built_in">cd</span> reaction</span><br><span class="line">cmake -B build</span><br><span class="line">cmake --build build/</span><br><span class="line">cmake --install build/ --prefix /your/install/path</span><br></pre></td></tr></table></figure>

<p>After installation, you can include and link against reaction in your own CMake-based project:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(reaction REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE reaction)</span><br></pre></td></tr></table></figure>

<h3 id="🚀-Quick-Start"><a href="#🚀-Quick-Start" class="headerlink" title="🚀 Quick Start"></a>🚀 Quick Start</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reaction/reaction.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> reaction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Reactive variables for stock prices</span></span><br><span class="line">    <span class="keyword">auto</span> buyPrice = <span class="built_in">var</span>(<span class="number">100.0</span>);      <span class="comment">// Price at which stock was bought</span></span><br><span class="line">    <span class="keyword">auto</span> currentPrice = <span class="built_in">var</span>(<span class="number">105.0</span>);  <span class="comment">// Current market price</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Use &#x27;calc&#x27; to compute profit or loss amount</span></span><br><span class="line">    <span class="keyword">auto</span> profit = <span class="built_in">calc</span>([&amp;]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">currentPrice</span>() - <span class="built_in">buyPrice</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Use &#x27;expr&#x27; to compute percentage gain/loss</span></span><br><span class="line">    <span class="keyword">auto</span> profitPercent = <span class="built_in">expr</span>(std::<span class="built_in">abs</span>(currentPrice - buyPrice) / buyPrice * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Use &#x27;action&#x27; to print the log whenever values change</span></span><br><span class="line">    <span class="keyword">auto</span> logger = <span class="built_in">action</span>([&amp;]() &#123;</span><br><span class="line">        std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Stock Update] Current Price: $&quot;</span> &lt;&lt; <span class="built_in">currentPrice</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Profit: $&quot;</span> &lt;&lt; <span class="built_in">profit</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; <span class="built_in">profitPercent</span>() &lt;&lt; <span class="string">&quot;%)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simulate price changes</span></span><br><span class="line">    currentPrice.<span class="built_in">value</span>(<span class="number">110.0</span>).<span class="built_in">value</span>(<span class="number">95.0</span>);  <span class="comment">// Stock price increases</span></span><br><span class="line">    *buyPrice = <span class="number">90.0</span>;                       <span class="comment">// Buy price adjusted</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📖-Basic-Usage"><a href="#📖-Basic-Usage" class="headerlink" title="📖 Basic Usage"></a>📖 Basic Usage</h3><h4 id="1-Reactive-Variables-var"><a href="#1-Reactive-Variables-var" class="headerlink" title="1. Reactive Variables: var"></a>1. Reactive Variables: <code>var</code></h4><p>Define reactive state variables with <code>var&lt;T&gt;</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);         <span class="comment">// int variable</span></span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);      <span class="comment">// double variable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Method-style get value:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = a.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>brief way:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = <span class="built_in">a</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>Method-style assignment:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Pointer-style assignment:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-Derived-Computation-calc"><a href="#2-Derived-Computation-calc" class="headerlink" title="2. Derived Computation: calc"></a>2. Derived Computation: calc</h4><p>Use <strong>calc</strong> to create reactive computations based on one or more var instances.</p>
<ul>
<li>Lambda Capture Style:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">auto</span> sum = reaction::<span class="built_in">calc</span>([=]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">b</span>();  <span class="comment">// Retrieve current values using a() and b()</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Parameter Binding Style (High Performance):</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([](<span class="keyword">auto</span> aa, <span class="keyword">auto</span> bb) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(aa) + std::<span class="built_in">to_string</span>(bb);</span><br><span class="line">&#125;, a, b);  <span class="comment">// Dependencies: a and b</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Declarative-Expression-expr"><a href="#3-Declarative-Expression-expr" class="headerlink" title="3. Declarative Expression: expr"></a>3. Declarative Expression: expr</h4><p>expr provides a clean and concise syntax to declare reactive expressions. The result automatically updates when any dependent variable changes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> result = reaction::<span class="built_in">expr</span>(a + b * <span class="number">3</span>);  <span class="comment">// result updates automatically when &#x27;a&#x27; or &#x27;b&#x27; change</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Reactive-Side-Effects-action"><a href="#4-Reactive-Side-Effects-action" class="headerlink" title="4. Reactive Side Effects: action"></a>4. Reactive Side Effects: action</h4><p>Register actions to perform side effects whenever the observed variables change.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> dds = reaction::<span class="built_in">action</span>([&amp;val]() &#123;</span><br><span class="line">    val = <span class="built_in">a</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Ofcourse, to get high performance can use Parameter Binding Style.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> dds = reaction::<span class="built_in">action</span>([&amp;val](<span class="keyword">auto</span> aa) &#123;</span><br><span class="line">    val = aa;</span><br><span class="line">&#125;, a);</span><br></pre></td></tr></table></figure>

<h4 id="5-Reactive-Struct-Fields-Field"><a href="#5-Reactive-Struct-Fields-Field" class="headerlink" title="5. Reactive Struct Fields: Field"></a>5. Reactive Struct Fields: <code>Field</code></h4><p>For complex types with reactive fields allow you to define struct-like variables whose members are individually reactive.</p>
<p>Here’s an example of a <code>PersonField</code> class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonField</span> : <span class="keyword">public</span> reaction::FieldBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PersonField</span>(std::string name, <span class="type">int</span> age):</span><br><span class="line">        <span class="built_in">m_name</span>(reaction::<span class="built_in">field</span>(<span class="keyword">this</span>, name)),</span><br><span class="line">        <span class="built_in">m_age</span>(reaction::<span class="built_in">field</span>(<span class="keyword">this</span>, age))&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name.<span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123; *m_name = name; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_age.<span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; *m_age = age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    reaction::Field&lt;std::string&gt; m_name;</span><br><span class="line">    reaction::Field&lt;<span class="type">int</span>&gt; m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = reaction::<span class="built_in">var</span>(PersonField&#123;<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> action = reaction::<span class="built_in">action</span>(</span><br><span class="line">    []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Action Trigger , name = &quot;</span> &lt;&lt; <span class="built_in">p</span>().<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; age = &quot;</span> &lt;&lt; <span class="built_in">p</span>().<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">setName</span>(<span class="string">&quot;Jackson&quot;</span>); <span class="comment">// Action Trigger</span></span><br><span class="line">p-&gt;<span class="built_in">setAge</span>(<span class="number">28</span>);         <span class="comment">// Action Trigger</span></span><br></pre></td></tr></table></figure>

<h4 id="6-Copy-and-move-semantics-support"><a href="#6-Copy-and-move-semantics-support" class="headerlink" title="6. Copy and move semantics support"></a>6. Copy and move semantics support</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>() + <span class="built_in">b</span>(); &#125;);</span><br><span class="line"><span class="keyword">auto</span> ds_copy = ds;</span><br><span class="line"><span class="keyword">auto</span> ds_move = std::<span class="built_in">move</span>(ds);</span><br><span class="line"><span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(ds));</span><br></pre></td></tr></table></figure>

<h4 id="7-Resetting-Nodes-and-Dependencies"><a href="#7-Resetting-Nodes-and-Dependencies" class="headerlink" title="7. Resetting Nodes and Dependencies"></a>7. Resetting Nodes and Dependencies</h4><p>The reaction framework allows you to <strong>reset a computation node</strong> by replacing its computation function.<br>This mechanism is useful when the result needs to be recalculated using a different logic or different dependencies after the node has been initially created.</p>
<p><code>Note:</code> <strong>The return value type cannot be changed</strong></p>
<p>Below is an example that demonstrates the reset functionality:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TestReset, ReactionTest) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(std::string&#123;<span class="string">&quot;2&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">auto</span> ds = reaction::<span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> std::<span class="built_in">to_string</span>(<span class="built_in">a</span>()); &#125;);</span><br><span class="line">    <span class="keyword">auto</span> ret = ds.<span class="built_in">set</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">b</span>() + <span class="string">&quot;set&quot;</span>; &#125;);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ret, reaction::ReactionError::NoErr);</span><br><span class="line"></span><br><span class="line">    ret = ds.<span class="built_in">set</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ret, reaction::ReactionError::ReturnTypeErr);</span><br><span class="line"></span><br><span class="line">    ret = ds.<span class="built_in">set</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">ds</span>(); &#125;);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(ret, reaction::ReactionError::CycleDepErr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-Trigger-Mode"><a href="#8-Trigger-Mode" class="headerlink" title="8. Trigger Mode"></a>8. Trigger Mode</h4><p>The <code>reaction</code> framework supports various triggering mode to control when reactive computations are re-evaluated. This example demonstrates three mode:</p>
<ol>
<li><strong>Value Change Trigger:</strong> The reactive computation is triggered only when the underlying value actually changes.</li>
<li><strong>Threshold Trigger:</strong> The reactive computation is triggered when the value crosses a specified threshold.</li>
<li><strong>Always Trigger:</strong> (Not explicitly shown in this example) Always triggers regardless of whether the value has changed.</li>
</ol>
<p>The trigger Mode can be specified by the type parameter</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> reaction;</span><br><span class="line"><span class="keyword">auto</span> stockPrice = <span class="built_in">var</span>(<span class="number">100.0</span>);</span><br><span class="line"><span class="keyword">auto</span> profit = <span class="built_in">expr</span>&lt;ChangedTrigger&gt;(<span class="built_in">stockPrice</span>() - <span class="number">100.0</span>);</span><br><span class="line"><span class="keyword">auto</span> assignAction = <span class="built_in">action</span>([=]() &#123;  <span class="comment">// defalut AlwaysTrigger</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Checky assign, price = &quot;</span> &lt;&lt; <span class="built_in">stockPrice</span>() &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">auto</span> sellAction = <span class="built_in">action</span>&lt;ThresholdTrigger&gt;([=]() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;It&#x27;s time to sell, profit = &quot;</span> &lt;&lt; <span class="built_in">profit</span>() &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">sellAction.<span class="built_in">setThreshold</span>([=]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">profit</span>() &gt; <span class="number">5.0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">*stockPrice = <span class="number">100.0</span>; <span class="comment">// assignAction trigger</span></span><br><span class="line">*stockPrice = <span class="number">101.0</span>; <span class="comment">// assignAction, profit trigger</span></span><br><span class="line">*stockPrice = <span class="number">106.0</span>; <span class="comment">// all trigger</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>You can even define a trigger mode yourself in your code, just include the <strong>checkTrigger</strong> method:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTrigger</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTrigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">expr</span>&lt;MyTrigger&gt;(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="9-Invalid-Strategies"><a href="#9-Invalid-Strategies" class="headerlink" title="9. Invalid Strategies"></a>9. Invalid Strategies</h4><p>In the <code>reaction</code> framework, all data sources <strong>obtained by users are actually in the form of weak references</strong>, and their actual memory is managed <strong>in the observer map</strong>.<br>Users can manually call the <strong>close</strong> method, so that all dependent data sources will also be closed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = reaction::<span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = reaction::<span class="built_in">var</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> dsA = reaction::<span class="built_in">calc</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line"><span class="keyword">auto</span> dsB = reaction::<span class="built_in">calc</span>([=]() &#123; <span class="keyword">return</span> <span class="built_in">dsA</span>() + <span class="built_in">b</span>(); &#125;);</span><br><span class="line">dsA.<span class="built_in">close</span>(); <span class="comment">//dsB will automatically close, cause dsB dependents dsA.</span></span><br><span class="line"><span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dsA));</span><br><span class="line"><span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(dsB));</span><br></pre></td></tr></table></figure>

<p>However, for scenarios where the lifecycle of a weak reference acquired by user ends, the <code>reaction</code> framework makes several strategy for different scenarios.</p>
<ul>
<li><p><strong>DirectCloseStrategy:</strong><br>The node is immediately closed (made invalid) when any of its dependencies become invalid.</p>
</li>
<li><p><strong>KeepCalcStrategy:</strong><br>The node continues to recalculate, its dependencies work normally.</p>
</li>
<li><p><strong>LastValStrategy:</strong><br>The node retains the last valid, its dependencies use the value to calculate.</p>
</li>
</ul>
<p>Below is a concise example that illustrates all three strategies:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;); <span class="comment">// default is DirectCloseStrategy</span></span><br><span class="line">        b.<span class="built_in">set</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">temp</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp lifecycle ends, b will end too.</span></span><br><span class="line">    <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b));</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">calc</span>&lt;AlwaysTrigger, KeepCalcStrategy&gt;([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;); <span class="comment">// default is DirectFailureStrategy</span></span><br><span class="line">        b.<span class="built_in">set</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">temp</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp lifecycle ends, b not be influenced.</span></span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b));</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">calc</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">calc</span>&lt;AlwaysTrigger, LastValStrategy&gt;([]() &#123; <span class="keyword">return</span> <span class="built_in">a</span>(); &#125;); <span class="comment">// default is DirectFailureStrategy</span></span><br><span class="line">        b.<span class="built_in">set</span>([]() &#123; <span class="keyword">return</span> <span class="built_in">temp</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp lifecycle ends, b use its last val to calculate.</span></span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b));</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">value</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(b.<span class="built_in">get</span>(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Likewise, you can define a strategy yourself in your code, just include the <strong>handleInvalid</strong> method:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStrategy</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleInvalid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">var</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">expr</span>&lt;AlwaysTrigger, MyStrategy&gt;(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-总结与展望"><a href="#5-总结与展望" class="headerlink" title="5. 总结与展望"></a>5. 总结与展望</h2><p>响应式编程正加速向全栈渗透，而 C++ 在此领域尚属“荒原”。Reaction 框架希望借助 C++20 的强大能力，为 C++ 开发者提供一种全新的响应式思维模型，特别是在嵌入式界面、工业软件与复杂状态管理等高性能场景中，具备独特的优势。</p>
<p><strong>接下来的章节，我们将从零开始实现 Reaction 框架，逐步剖析其设计细节与核心实现逻辑。</strong></p>
<p>欢迎关注后续内容，一起走进响应式 C++ 的世界！</p>
<hr>
<p><em>如果你对本项目感兴趣，欢迎留言交流，或访问 GitHub 获取源码与进展！</em><br><a target="_blank" rel="noopener" href="https://github.com/lumia431/reaction">https://github.com/lumia431/reaction</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/12/Reaction%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" data-id="cm9e9088i0000iikyc9pu2b4s" data-title="从零实现响应式框架——基本概念和设计思路" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Reaction/">Reaction</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modern-Cpp/" rel="tag">Modern-Cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactive-programming/" rel="tag">Reactive-programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TMP/" rel="tag">TMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" rel="tag">\[Reactive-programming, C++, Modern-Cpp, TMP]</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/Modern-Cpp/" style="font-size: 20px;">Modern-Cpp</a> <a href="/tags/Reactive-programming/" style="font-size: 20px;">Reactive-programming</a> <a href="/tags/TMP/" style="font-size: 20px;">TMP</a> <a href="/tags/Reactive-programming-C-Modern-Cpp-TMP/" style="font-size: 10px;">\[Reactive-programming, C++, Modern-Cpp, TMP]</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/05/27/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/">第八章：节点关系图的实现</a>
          </li>
        
          <li>
            <a href="/2025/05/13/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/">第七章：表达式模板的使用</a>
          </li>
        
          <li>
            <a href="/2025/05/09/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84private%E6%88%90%E5%91%98/">第六章：编译期反射 private 成员</a>
          </li>
        
          <li>
            <a href="/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/">第五章：编译期反射初探！</a>
          </li>
        
          <li>
            <a href="/2025/05/07/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/">第三章：实现数据源的生命周期管理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Lummy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>